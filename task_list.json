[
  {
    "id": "project-setup",
    "category": "infrastructure",
    "description": "Set up Go project with a sensible stack, dependencies, and basic structure",
    "steps": [
      "Run init.sh successfully",
      "Verify Go module is initialized (go.mod exists)",
      "Confirm single binary 'vex' can be built with subcommands",
      "Verify basic package structure exists (cmd/, pkg/, internal/)",
      "Confirm MinIO can be started locally for testing"
    ],
    "completed": true
  },
  {
    "id": "object-store-abstraction",
    "category": "infrastructure",
    "description": "Implement ObjectStore interface with S3-compatible and filesystem backends",
    "steps": [
      "Verify ObjectStore interface exists with Get, Head, PutIfAbsent, PutIfMatch, List, Delete methods",
      "Test S3-compatible backend connects to MinIO and performs basic CRUD",
      "Test filesystem backend works for unit tests",
      "Verify conditional writes (If-None-Match, If-Match) work correctly",
      "Test 409/412 conflict errors are returned and handled properly",
      "Verify strong read-after-write semantics work",
      "Test checksum/integrity verification with SHA-256"
    ],
    "completed": true,
    "depends_on": [
      "project-setup"
    ],
    "scope": [
      "pkg/objectstore/",
      "internal/storage/"
    ]
  },
  {
    "id": "api-scaffolding",
    "category": "api",
    "description": "Create HTTP API scaffolding with router, auth middleware, and compression support",
    "steps": [
      "Start server on configurable port",
      "Verify Authorization: Bearer token auth works",
      "Test unauthenticated requests return 401",
      "Verify gzip request body decompression works (Content-Encoding: gzip)",
      "Verify gzip response compression when Accept-Encoding: gzip is sent",
      "Test error responses match format: {\"status\":\"error\",\"error\":\"...\"}"
    ],
    "completed": true,
    "depends_on": [
      "project-setup"
    ],
    "scope": [
      "cmd/vex/",
      "pkg/api/",
      "internal/http/"
    ]
  },
  {
    "id": "namespace-state-management",
    "category": "functional",
    "description": "Implement namespace state.json management with ETag-based CAS",
    "steps": [
      "Verify state.json schema matches spec (format_version, schema, wal, index, etc.)",
      "Test CAS loop correctly handles ETag mismatches with retry",
      "Verify state.wal.head_seq strictly increases by 1",
      "Test state.index.indexed_wal_seq never exceeds wal.head_seq",
      "Verify created_at and updated_at timestamps are properly managed",
      "Test schema type immutability enforcement",
      "Verify pending_rebuilds tracking for index build status"
    ],
    "completed": true,
    "depends_on": [
      "object-store-abstraction"
    ],
    "scope": [
      "internal/namespace/",
      "pkg/state/"
    ]
  },
  {
    "id": "namespace-name-validation",
    "category": "functional",
    "description": "Validate namespace names match pattern [A-Za-z0-9-_.]{1,128}",
    "steps": [
      "Test valid namespace names are accepted (letters, numbers, dash, underscore, dot)",
      "Test names longer than 128 chars are rejected with 400",
      "Test empty names are rejected",
      "Test names with invalid characters are rejected"
    ],
    "completed": true,
    "depends_on": [
      "api-scaffolding"
    ],
    "scope": [
      "internal/namespace/"
    ]
  },
  {
    "id": "document-id-validation",
    "category": "functional",
    "description": "Validate document IDs (u64, UUID, or strings up to 64 bytes)",
    "steps": [
      "Test u64 IDs are accepted",
      "Test UUID IDs are accepted",
      "Test string IDs up to 64 bytes are accepted",
      "Test string IDs over 64 bytes are rejected with 400",
      "Test ID normalization to typed representation"
    ],
    "completed": true,
    "depends_on": [
      "api-scaffolding"
    ],
    "scope": [
      "internal/document/"
    ]
  },
  {
    "id": "attribute-name-validation",
    "category": "functional",
    "description": "Validate attribute names (up to 128 chars, no $ prefix)",
    "steps": [
      "Test attribute names up to 128 chars are accepted",
      "Test attribute names over 128 chars are rejected with 400",
      "Test attribute names starting with $ are rejected with 400",
      "Test 'vector' is a valid special attribute name"
    ],
    "completed": true,
    "depends_on": [
      "api-scaffolding"
    ],
    "scope": [
      "internal/schema/"
    ]
  },
  {
    "id": "schema-type-system",
    "category": "functional",
    "description": "Implement schema type system with all supported types",
    "steps": [
      "Test string type is supported",
      "Test int (i64) type is supported",
      "Test uint (u64) type is supported",
      "Test float (f64) type is supported",
      "Test uuid (16B) type is supported",
      "Test datetime (ms epoch) type is supported",
      "Test bool type is supported",
      "Test array variants of all types are supported",
      "Verify changing attribute type returns 400"
    ],
    "completed": true,
    "depends_on": [
      "namespace-state-management"
    ],
    "scope": [
      "internal/schema/"
    ]
  },
  {
    "id": "schema-field-options",
    "category": "functional",
    "description": "Implement schema field options (filterable, regex, full_text_search, vector)",
    "steps": [
      "Test filterable option (default true, false when regex/fts enabled)",
      "Test regex option (default false)",
      "Test full_text_search boolean option",
      "Test full_text_search object with tokenizer/language/etc",
      "Test vector object with type and ann fields",
      "Verify filterable and full_text_search can be updated online"
    ],
    "completed": true,
    "depends_on": [
      "schema-type-system"
    ],
    "scope": [
      "internal/schema/"
    ]
  },
  {
    "id": "vector-config",
    "category": "functional",
    "description": "Implement vector configuration with dimensions, dtype, and distance metric",
    "steps": [
      "Test vector type supports f16 and f32 dtypes",
      "Test cosine_distance metric is supported (default)",
      "Test euclidean_squared metric is supported",
      "Test dot_product is only accepted when compat_mode != turbopuffer",
      "Verify distance_metric is set on first write with vectors",
      "Test vectors can be encoded as float array",
      "Test vectors can be encoded as base64"
    ],
    "completed": true,
    "depends_on": [
      "schema-type-system"
    ],
    "scope": [
      "internal/vector/"
    ]
  },
  {
    "id": "wal-entry-format",
    "category": "functional",
    "description": "Implement WAL entry format with protobuf encoding and zstd compression",
    "steps": [
      "Verify WAL entries stored as .wal.zst compressed blobs",
      "Test protobuf encoding with WalEntry schema",
      "Verify sub-batches contain request_id, received_at_ms, mutations, stats",
      "Test SHA-256 checksum is computed and stored",
      "Verify deterministic encoding (stable sort by docID, stable schema delta ordering)",
      "Test canonicalization of inputs (field ordering, ID normalization, datetime parsing)",
      "Verify invalid datetime format returns 400",
      "Verify non-UTF-8 strings return 400"
    ],
    "completed": true,
    "depends_on": [
      "object-store-abstraction"
    ],
    "scope": [
      "internal/wal/"
    ]
  },
  {
    "id": "write-api-basic",
    "category": "api",
    "description": "Implement basic write endpoint POST /v2/namespaces/:namespace",
    "steps": [
      "Test namespace is implicitly created on first write",
      "Verify write returns only after WAL is committed to object storage",
      "Test upsert_rows creates/updates documents",
      "Test deletes removes documents by ID",
      "Verify response includes rows_affected, rows_upserted, rows_patched, rows_deleted"
    ],
    "completed": true,
    "depends_on": [
      "wal-entry-format",
      "api-scaffolding",
      "namespace-state-management"
    ],
    "scope": [
      "pkg/api/write.go",
      "internal/write/"
    ]
  },
  {
    "id": "write-upsert-rows",
    "category": "functional",
    "description": "Implement upsert_rows with row-oriented document format",
    "steps": [
      "Test upsert_rows accepts array of document objects",
      "Verify documents include id and arbitrary attributes",
      "Test vector attribute is properly handled",
      "Verify duplicate IDs use last-write-wins (later in array wins)",
      "Test schema is inferred from first write"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-upsert-columns",
    "category": "functional",
    "description": "Implement upsert_columns with column-oriented document format",
    "steps": [
      "Test upsert_columns accepts columnar format",
      "Verify ids array and attribute arrays are properly parsed",
      "Test duplicate IDs in columnar format return 400"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-patch-rows",
    "category": "functional",
    "description": "Implement patch_rows for partial document updates",
    "steps": [
      "Test patch_rows updates only specified attributes",
      "Verify patch to missing ID is silently ignored (no doc created)",
      "Test vector attribute cannot be patched (returns 400)",
      "Verify duplicate IDs use last-write-wins"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-patch-columns",
    "category": "functional",
    "description": "Implement patch_columns for columnar partial updates",
    "steps": [
      "Test patch_columns works with columnar format",
      "Verify vector attribute cannot be patched in columns",
      "Test duplicate IDs in columnar patch return 400"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-deletes",
    "category": "functional",
    "description": "Implement deletes for removing documents by ID",
    "steps": [
      "Test deletes array removes documents by ID",
      "Verify deleting non-existent ID succeeds silently"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-delete-by-filter",
    "category": "functional",
    "description": "Implement delete_by_filter with two-phase execution",
    "steps": [
      "Test delete_by_filter removes documents matching filter",
      "Verify delete_by_filter runs BEFORE all other operations",
      "Test max 5,000,000 rows can be deleted",
      "Verify exceeding limit with allow_partial=false returns 400",
      "Test allow_partial=true succeeds and sets rows_remaining=true",
      "Verify two-phase with re-evaluation (Read Committed semantics)"
    ],
    "completed": true,
    "depends_on": [
      "filter-evaluation",
      "write-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-patch-by-filter",
    "category": "functional",
    "description": "Implement patch_by_filter with two-phase execution",
    "steps": [
      "Test patch_by_filter updates documents matching filter",
      "Verify patch_by_filter runs AFTER delete_by_filter, BEFORE other ops",
      "Test max 500,000 rows can be patched",
      "Verify exceeding limit with allow_partial=false returns 400",
      "Test allow_partial=true succeeds and sets rows_remaining=true",
      "Verify two-phase with re-evaluation (Read Committed semantics)",
      "Test vector attribute cannot be patched via filter"
    ],
    "completed": true,
    "depends_on": [
      "filter-evaluation",
      "write-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-copy-from-namespace",
    "category": "functional",
    "description": "Implement copy_from_namespace for server-side bulk copy",
    "steps": [
      "Test copy_from_namespace bulk upserts from source namespace",
      "Verify runs AFTER patch_by_filter, BEFORE explicit upserts",
      "Test can be combined with other write operations",
      "Verify source namespace read at consistent snapshot"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic",
      "query-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-schema-updates",
    "category": "functional",
    "description": "Implement schema object in write requests for explicit schema changes",
    "steps": [
      "Test schema can be specified in write request",
      "Verify schema changes are applied atomically with write",
      "Test changing attribute type is rejected with 400",
      "Verify filterable and full_text_search can be updated"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic",
      "schema-type-system"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-conditional-upsert",
    "category": "functional",
    "description": "Implement conditional upsert with upsert_condition",
    "steps": [
      "Test upsert_condition evaluates against current doc value",
      "Verify doc exists + condition met = apply upsert",
      "Verify doc exists + condition not met = skip",
      "Verify doc missing = apply unconditionally",
      "Test $ref_new references inside conditions",
      "Verify conditions are atomic with writing"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic",
      "filter-evaluation"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-conditional-patch",
    "category": "functional",
    "description": "Implement conditional patch with patch_condition",
    "steps": [
      "Test patch_condition evaluates against current doc value",
      "Verify doc missing = skip (no doc created)",
      "Test $ref_new references inside conditions"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic",
      "filter-evaluation"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-conditional-delete",
    "category": "functional",
    "description": "Implement conditional delete with delete_condition",
    "steps": [
      "Test delete_condition evaluates against current doc value",
      "Verify doc missing = skip",
      "Test $ref_new attributes are supplied as null for delete_condition"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic",
      "filter-evaluation"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-request-ordering",
    "category": "functional",
    "description": "Implement canonical write operation ordering within single request",
    "steps": [
      "Verify order: delete_by_filter -> patch_by_filter -> copy_from_namespace -> upserts -> patches -> deletes",
      "Test delete_by_filter can be 'resurrected' by later upsert in same request",
      "Verify all operations are atomic (no partial visibility)"
    ],
    "completed": true,
    "depends_on": [
      "write-delete-by-filter",
      "write-patch-by-filter",
      "write-copy-from-namespace",
      "write-upsert-rows",
      "write-patch-rows",
      "write-deletes"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-batching",
    "category": "functional",
    "description": "Implement write batching at 1 WAL entry per second per namespace",
    "steps": [
      "Verify at most 1 WAL entry committed per second per namespace",
      "Test concurrent writes batch into same WAL entry",
      "Verify batch window or size threshold triggers commit",
      "Test commit latency up to 1 second for window alignment"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-idempotency",
    "category": "functional",
    "description": "Implement request idempotency with request_id",
    "steps": [
      "Test request_id is assigned or provided for each write",
      "Verify duplicate request_id returns original response",
      "Test de-duplication works within bounded time window"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-backpressure",
    "category": "functional",
    "description": "Implement write backpressure at 2GB unindexed threshold",
    "steps": [
      "Test writes return 429 when unindexed data > 2GB",
      "Verify disable_backpressure=true allows writes above threshold",
      "Test bytes_unindexed_est is tracked in state"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic",
      "namespace-state-management"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "write-max-batch-size",
    "category": "functional",
    "description": "Enforce 256MB max upsert batch request size",
    "steps": [
      "Test requests under 256MB are accepted",
      "Verify requests over 256MB return 413"
    ],
    "completed": true,
    "depends_on": [
      "write-api-basic"
    ],
    "scope": [
      "internal/write/"
    ]
  },
  {
    "id": "wal-commit-protocol",
    "category": "functional",
    "description": "Implement WAL commit protocol with object storage durability",
    "steps": [
      "Verify WAL entry PUT uses If-None-Match: * for idempotency",
      "Test state.json update uses If-Match for CAS",
      "Verify success returned only after both WAL and state are committed",
      "Test CAS retry loop on ETag mismatch",
      "Verify WAL key not re-uploaded on state retry"
    ],
    "completed": true,
    "depends_on": [
      "wal-entry-format",
      "namespace-state-management"
    ],
    "scope": [
      "internal/wal/"
    ]
  },
  {
    "id": "tail-materialization",
    "category": "functional",
    "description": "Implement tail materialization for unindexed WAL overlay",
    "steps": [
      "Test query node reads WAL tail from object storage",
      "Verify in-memory (RAM) tier for recent sub-batches",
      "Test NVMe tier for spilled tail blocks",
      "Verify tail supports vector scan and filter evaluation"
    ],
    "completed": true,
    "depends_on": [
      "wal-commit-protocol"
    ],
    "scope": [
      "internal/tail/"
    ]
  },
  {
    "id": "query-api-basic",
    "category": "api",
    "description": "Implement basic query endpoint POST /v2/namespaces/:namespace/query",
    "steps": [
      "Test query endpoint accepts POST with JSON body",
      "Verify rank_by field is required (unless aggregate_by)",
      "Test include_attributes filters response attributes",
      "Test exclude_attributes filters response attributes",
      "Verify limit/top_k controls result count (max 10,000)",
      "Test response includes rows array with id and $dist"
    ],
    "completed": true,
    "depends_on": [
      "api-scaffolding",
      "tail-materialization"
    ],
    "scope": [
      "pkg/api/query.go",
      "internal/query/"
    ]
  },
  {
    "id": "query-vector-ann",
    "category": "functional",
    "description": "Implement vector ANN search with rank_by [\"vector\", \"ANN\", <vector>]",
    "steps": [
      "Test exact exhaustive vector search works (before ANN index)",
      "Verify $dist contains distance from query vector",
      "Test vector_encoding: float accepts float array",
      "Test vector_encoding: base64 accepts base64 encoded vector",
      "Verify cosine_distance metric works correctly",
      "Verify euclidean_squared metric works correctly"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic",
      "vector-config"
    ],
    "scope": [
      "internal/query/",
      "internal/vector/"
    ]
  },
  {
    "id": "query-order-by-attribute",
    "category": "functional",
    "description": "Implement order-by attribute queries with rank_by [\"attr\", \"asc|desc\"]",
    "steps": [
      "Test rank_by [\"id\", \"asc\"] orders by id ascending",
      "Test rank_by [\"timestamp\", \"desc\"] orders by timestamp descending",
      "Verify $dist is omitted for order-by queries",
      "Test 'per' diversification option"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "query-consistency-strong",
    "category": "functional",
    "description": "Implement strong consistency mode (default)",
    "steps": [
      "Verify strong is default consistency mode",
      "Test strong queries include ALL committed WAL entries at query start",
      "Verify cache is refreshed for strong queries",
      "Test strong query fails if snapshot cannot be refreshed"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic",
      "tail-materialization"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "query-consistency-eventual",
    "category": "functional",
    "description": "Implement eventual consistency mode",
    "steps": [
      "Test eventual consistency can be requested",
      "Verify eventual may be stale up to 60 seconds",
      "Test eventual searches only up to 128 MiB of tail",
      "Verify 128 MiB window uses newest WAL entries first"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic",
      "tail-materialization"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "query-disable-backpressure-error",
    "category": "functional",
    "description": "Implement strong query error when disable_backpressure and unindexed > 2GB",
    "steps": [
      "Test strong query returns 503 when disable_backpressure=true and unindexed > 2GB",
      "Verify eventual queries continue to work in same scenario"
    ],
    "completed": true,
    "depends_on": [
      "query-consistency-strong",
      "write-backpressure"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "filter-evaluation",
    "category": "functional",
    "description": "Implement filter AST parsing and evaluation",
    "steps": [
      "Test And operator [\"And\", [f1, f2, ...]]",
      "Test Or operator [\"Or\", [f1, f2, ...]]",
      "Test Not operator [\"Not\", f]",
      "Verify boolean operators can be nested"
    ],
    "completed": true,
    "depends_on": [
      "schema-type-system"
    ],
    "scope": [
      "internal/filter/"
    ]
  },
  {
    "id": "filter-eq-noteq",
    "category": "functional",
    "description": "Implement Eq and NotEq filter operators",
    "steps": [
      "Test [\"attr\", \"Eq\", value] matches exact value",
      "Test [\"attr\", \"Eq\", null] matches missing attribute",
      "Test [\"attr\", \"NotEq\", value] excludes exact value",
      "Test [\"attr\", \"NotEq\", null] matches attribute present"
    ],
    "completed": true,
    "depends_on": [
      "filter-evaluation"
    ],
    "scope": [
      "internal/filter/"
    ]
  },
  {
    "id": "filter-in-notin",
    "category": "functional",
    "description": "Implement In and NotIn filter operators",
    "steps": [
      "Test In operator matches any value in set",
      "Test NotIn operator excludes all values in set"
    ],
    "completed": true,
    "depends_on": [
      "filter-evaluation"
    ],
    "scope": [
      "internal/filter/"
    ]
  },
  {
    "id": "filter-comparisons",
    "category": "functional",
    "description": "Implement Lt, Lte, Gt, Gte filter operators",
    "steps": [
      "Test Lt operator for numeric comparison",
      "Test Lte operator for numeric comparison",
      "Test Gt operator for numeric comparison",
      "Test Gte operator for numeric comparison",
      "Verify strings use lexicographic comparison",
      "Verify datetimes compare as numeric milliseconds"
    ],
    "completed": true,
    "depends_on": [
      "filter-evaluation"
    ],
    "scope": [
      "internal/filter/"
    ]
  },
  {
    "id": "filter-array-ops",
    "category": "functional",
    "description": "Implement array filter operators",
    "steps": [
      "Test Contains operator",
      "Test NotContains operator",
      "Test ContainsAny operator",
      "Test NotContainsAny operator",
      "Test AnyLt operator",
      "Test AnyLte operator",
      "Test AnyGt operator",
      "Test AnyGte operator"
    ],
    "completed": true,
    "depends_on": [
      "filter-evaluation"
    ],
    "scope": [
      "internal/filter/"
    ]
  },
  {
    "id": "filter-glob",
    "category": "functional",
    "description": "Implement Glob, NotGlob, IGlob, NotIGlob filter operators",
    "steps": [
      "Test Glob with Unix-style glob patterns",
      "Test NotGlob excludes matching patterns",
      "Test IGlob for case-insensitive matching",
      "Test NotIGlob for case-insensitive exclusion",
      "Verify prefix globs compile to range queries"
    ],
    "completed": true,
    "depends_on": [
      "filter-evaluation"
    ],
    "scope": [
      "internal/filter/"
    ]
  },
  {
    "id": "filter-regex",
    "category": "functional",
    "description": "Implement Regex filter operator (requires regex: true in schema)",
    "steps": [
      "Test Regex matches string patterns",
      "Verify regex: true must be set in schema",
      "Test regex without schema option returns error"
    ],
    "completed": true,
    "depends_on": [
      "filter-evaluation",
      "schema-field-options"
    ],
    "scope": [
      "internal/filter/"
    ]
  },
  {
    "id": "filter-fulltext-tokens",
    "category": "functional",
    "description": "Implement ContainsTokenSequence and ContainsAllTokens filters",
    "steps": [
      "Test ContainsTokenSequence for adjacent ordered tokens",
      "Test ContainsAllTokens regardless of adjacency",
      "Test last_as_prefix: true option for prefix matching"
    ],
    "completed": true,
    "depends_on": [
      "filter-evaluation"
    ],
    "scope": [
      "internal/filter/"
    ]
  },
  {
    "id": "query-with-filters",
    "category": "functional",
    "description": "Integrate filters into query execution",
    "steps": [
      "Test query with filters field restricts results",
      "Verify filters applied before ranking",
      "Test combining vector search with filters"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic",
      "filter-evaluation"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "query-aggregations",
    "category": "functional",
    "description": "Implement aggregations in queries",
    "steps": [
      "Test aggregate_by returns aggregations object",
      "Verify aggregations compute correctly over result set"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "query-group-by",
    "category": "functional",
    "description": "Implement grouped aggregations with group_by",
    "steps": [
      "Test group_by returns aggregation_groups object",
      "Verify groups are computed correctly"
    ],
    "completed": true,
    "depends_on": [
      "query-aggregations"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "query-multi-query",
    "category": "functional",
    "description": "Implement multi-query with snapshot isolation",
    "steps": [
      "Test queries array executes multiple subqueries",
      "Verify all subqueries use same consistent snapshot",
      "Test response includes results array in same order",
      "Verify max 16 subqueries per request"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "query-response-format",
    "category": "functional",
    "description": "Implement complete query response format",
    "steps": [
      "Verify rows array format with id, $dist, attributes",
      "Test billing object is present (can be zeros)",
      "Test performance object with cache metrics and timing"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "query-concurrency-limit",
    "category": "functional",
    "description": "Enforce query concurrency limit per namespace (default 16)",
    "steps": [
      "Test queries queue when concurrency exceeds 16",
      "Verify queued queries eventually execute"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "indexer-process",
    "category": "functional",
    "description": "Implement indexer process that watches WAL and builds indexes",
    "steps": [
      "Test indexer watches namespace state for WAL changes",
      "Verify indexer processes WAL range (indexed_wal_seq+1 .. head_seq]",
      "Test indexer runs asynchronously after WAL commit"
    ],
    "completed": true,
    "depends_on": [
      "wal-commit-protocol",
      "namespace-state-management"
    ],
    "scope": [
      "cmd/vex-indexer/",
      "internal/indexer/"
    ]
  },
  {
    "id": "index-manifest-format",
    "category": "functional",
    "description": "Implement index manifest format",
    "steps": [
      "Verify manifest includes format_version, namespace, generated_at",
      "Test indexed_wal_seq tracks what WAL range is indexed",
      "Verify segments array lists all segment details",
      "Test stats includes approx_row_count and approx_logical_bytes"
    ],
    "completed": true,
    "depends_on": [
      "indexer-process"
    ],
    "scope": [
      "internal/index/"
    ]
  },
  {
    "id": "index-segment-format",
    "category": "functional",
    "description": "Implement immutable index segment format",
    "steps": [
      "Test segments are immutable once written",
      "Verify each segment covers WAL sequence interval (start_wal_seq, end_wal_seq)",
      "Test segment includes docs_key, vectors_key, filter_keys"
    ],
    "completed": true,
    "depends_on": [
      "indexer-process"
    ],
    "scope": [
      "internal/index/"
    ]
  },
  {
    "id": "index-lsm-model",
    "category": "functional",
    "description": "Implement LSM-like incremental indexing model",
    "steps": [
      "Test L0 segments built frequently from WAL batches",
      "Verify periodic compaction merges segments into L1/L2",
      "Test query reads across all segments + tail"
    ],
    "completed": true,
    "depends_on": [
      "index-segment-format"
    ],
    "scope": [
      "internal/index/"
    ]
  },
  {
    "id": "index-publish-protocol",
    "category": "functional",
    "description": "Implement atomic index publishing protocol",
    "steps": [
      "Verify all segment objects uploaded before manifest",
      "Test manifest never references missing objects",
      "Verify state.json CAS update after manifest upload",
      "Test indexed_wal_seq advances only on successful publish"
    ],
    "completed": true,
    "depends_on": [
      "indexer-process",
      "index-manifest-format"
    ],
    "scope": [
      "internal/index/"
    ]
  },
  {
    "id": "index-recovery",
    "category": "functional",
    "description": "Implement partial index build recovery",
    "steps": [
      "Test indexer crash after segment upload but before manifest is safe",
      "Verify orphan objects are unreachable and can be GCed"
    ],
    "completed": true,
    "depends_on": [
      "index-publish-protocol"
    ],
    "scope": [
      "internal/index/"
    ]
  },
  {
    "id": "vector-ivf-index",
    "category": "functional",
    "description": "Implement IVF (centroid clusters) ANN index",
    "steps": [
      "Test vectors.centroids.bin is created (small, cacheable)",
      "Verify vectors.clusters.pack contains packed cluster data",
      "Test vectors.cluster_offsets.bin maps cluster to offset/length",
      "Verify cold query flow: load centroids, find nearest clusters, fetch cluster data"
    ],
    "completed": true,
    "depends_on": [
      "indexer-process",
      "query-vector-ann"
    ],
    "scope": [
      "internal/vector/"
    ]
  },
  {
    "id": "vector-query-ann-path",
    "category": "functional",
    "description": "Implement ANN query path with index",
    "steps": [
      "Test ANN search uses index when available",
      "Verify nprobe centroids are searched",
      "Test multi-range GET for cluster data (object store optimization)",
      "Verify exact distances computed for final top_k"
    ],
    "completed": true,
    "depends_on": [
      "vector-ivf-index",
      "query-vector-ann"
    ],
    "scope": [
      "internal/query/",
      "internal/vector/"
    ]
  },
  {
    "id": "vector-recall-aware-filtering",
    "category": "functional",
    "description": "Implement recall-aware filtering for ANN + filters",
    "steps": [
      "Test filter selectivity estimation",
      "Verify exact search fallback when filter is very selective",
      "Test candidate oversampling for ANN with filters",
      "Verify adaptive probe/candidate budget increase"
    ],
    "completed": true,
    "depends_on": [
      "vector-query-ann-path",
      "query-with-filters"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "filter-index-bitmaps",
    "category": "functional",
    "description": "Implement roaring bitmap indexes for filterable attributes",
    "steps": [
      "Test value -> bitmap mapping for scalar attributes",
      "Verify range queries with numeric/datetime fields",
      "Test inverted mapping for array elements"
    ],
    "completed": true,
    "depends_on": [
      "indexer-process",
      "filter-evaluation"
    ],
    "scope": [
      "internal/filter/"
    ]
  },
  {
    "id": "query-deduplication",
    "category": "functional",
    "description": "Implement deduplication (last-write-wins) across segments",
    "steps": [
      "Verify highest WAL seq version is authoritative",
      "Test newest segments/tail processed first",
      "Verify tombstones (deletes) exclude docs from results"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic",
      "index-lsm-model"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "bm25-schema-config",
    "category": "functional",
    "description": "Implement full-text search schema configuration",
    "steps": [
      "Test full_text_search: true enables FTS",
      "Verify full_text_search object options: tokenizer, case_sensitive, language",
      "Test stemming, remove_stopwords, ascii_folding options",
      "Verify BM25 params k1, b configuration"
    ],
    "completed": true,
    "depends_on": [
      "schema-field-options"
    ],
    "scope": [
      "internal/fts/"
    ]
  },
  {
    "id": "bm25-indexing",
    "category": "functional",
    "description": "Implement BM25 index building",
    "steps": [
      "Test tokenization with word_v3 default tokenizer",
      "Verify BM25 index segments are created",
      "Test FTS index referenced in segment fts_keys"
    ],
    "completed": true,
    "depends_on": [
      "indexer-process",
      "bm25-schema-config"
    ],
    "scope": [
      "internal/fts/"
    ]
  },
  {
    "id": "bm25-query",
    "category": "functional",
    "description": "Implement BM25 ranking queries",
    "steps": [
      "Test rank_by [\"field\", \"BM25\", \"query\"] syntax",
      "Verify $dist contains BM25 score",
      "Test documents with score zero excluded"
    ],
    "completed": true,
    "depends_on": [
      "bm25-indexing",
      "query-api-basic"
    ],
    "scope": [
      "internal/query/",
      "internal/fts/"
    ]
  },
  {
    "id": "bm25-operators",
    "category": "functional",
    "description": "Implement BM25 compositional operators",
    "steps": [
      "Test Sum operator combines clause scores",
      "Test Max operator takes maximum score",
      "Test Product operator applies weight/boost",
      "Verify filters in rank_by yield score 1 or 0"
    ],
    "completed": true,
    "depends_on": [
      "bm25-query"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "bm25-prefix-query",
    "category": "functional",
    "description": "Implement BM25 prefix matching with last_as_prefix",
    "steps": [
      "Test last_as_prefix: true for typeahead",
      "Verify prefix matches score 1.0"
    ],
    "completed": true,
    "depends_on": [
      "bm25-query"
    ],
    "scope": [
      "internal/fts/"
    ]
  },
  {
    "id": "schema-index-rebuild",
    "category": "functional",
    "description": "Implement schema index rebuild with HTTP 202 gating",
    "steps": [
      "Test enabling filterable triggers index rebuild",
      "Verify query returns 202 until new index ready",
      "Test FTS parameter changes rebuild in background",
      "Verify queries use old settings until new ready"
    ],
    "completed": true,
    "depends_on": [
      "indexer-process",
      "schema-field-options"
    ],
    "scope": [
      "internal/index/"
    ]
  },
  {
    "id": "nvme-cache",
    "category": "functional",
    "description": "Implement NVMe SSD cache for index objects",
    "steps": [
      "Test content-addressable cache keyed by (object_key, etag)",
      "Verify configurable size budget (default 95% of disk)",
      "Test LRU eviction by bytes with access-time tracking",
      "Verify pinned set for warming namespaces not evictable"
    ],
    "completed": true,
    "depends_on": [
      "object-store-abstraction"
    ],
    "scope": [
      "internal/cache/"
    ]
  },
  {
    "id": "ram-cache",
    "category": "functional",
    "description": "Implement RAM cache for hot index structures",
    "steps": [
      "Test ANN centroids cached in RAM",
      "Verify posting dictionaries and bitmap shards cached",
      "Test shard-aware LRU eviction",
      "Verify per-namespace budget caps for multi-tenancy"
    ],
    "completed": true,
    "depends_on": [
      "nvme-cache"
    ],
    "scope": [
      "internal/cache/"
    ]
  },
  {
    "id": "cache-correctness-invariant",
    "category": "functional",
    "description": "Verify cache eviction never affects correctness",
    "steps": [
      "Test missing cached object is fetched from object storage",
      "Verify cold path always works"
    ],
    "completed": true,
    "depends_on": [
      "nvme-cache",
      "ram-cache"
    ],
    "scope": [
      "internal/cache/"
    ]
  },
  {
    "id": "routing-rendezvous-hashing",
    "category": "functional",
    "description": "Implement rendezvous hashing for cache-locality routing",
    "steps": [
      "Test home_node(namespace) computed consistently",
      "Verify requests route to home node when possible",
      "Test any node can serve any namespace (fallback)"
    ],
    "completed": true,
    "depends_on": [
      "api-scaffolding"
    ],
    "scope": [
      "internal/routing/"
    ]
  },
  {
    "id": "routing-proxy",
    "category": "functional",
    "description": "Implement request proxy to home node with fallback",
    "steps": [
      "Test requests proxy to home node",
      "Verify bounded timeout on proxy",
      "Test fallback to local serve if proxy fails",
      "Verify writes also proxy to home node"
    ],
    "completed": true,
    "depends_on": [
      "routing-rendezvous-hashing"
    ],
    "scope": [
      "internal/routing/"
    ]
  },
  {
    "id": "membership-static",
    "category": "functional",
    "description": "Implement static cluster membership from config",
    "steps": [
      "Test static node list in config",
      "Verify membership used for routing calculations"
    ],
    "completed": true,
    "depends_on": [
      "routing-rendezvous-hashing"
    ],
    "scope": [
      "internal/membership/"
    ]
  },
  {
    "id": "membership-gossip",
    "category": "functional",
    "description": "Implement optional gossip membership for dynamic clusters",
    "steps": [
      "Test gossip-based membership discovery (optional)",
      "Verify dynamic membership updates routing"
    ],
    "completed": true,
    "depends_on": [
      "membership-static"
    ],
    "scope": [
      "internal/membership/"
    ]
  },
  {
    "id": "metadata-endpoint",
    "category": "api",
    "description": "Implement GET /v1/namespaces/:namespace/metadata endpoint",
    "steps": [
      "Test endpoint returns namespace metadata",
      "Verify schema field is included",
      "Test approx_logical_bytes and approx_row_count returned",
      "Verify created_at and updated_at timestamps",
      "Test encryption field present (SSE default true)",
      "Verify index.status (updating or up-to-date)",
      "Test unindexed_bytes shown when updating"
    ],
    "completed": true,
    "depends_on": [
      "namespace-state-management"
    ],
    "scope": [
      "pkg/api/metadata.go"
    ]
  },
  {
    "id": "warm-cache-endpoint",
    "category": "api",
    "description": "Implement GET /v1/namespaces/:namespace/hint_cache_warm endpoint",
    "steps": [
      "Test endpoint returns 200 immediately",
      "Verify request routes to home node",
      "Test cache warm task is enqueued",
      "Verify prefetch: centroids, cluster offsets, filter bitmaps, doc column headers"
    ],
    "completed": true,
    "depends_on": [
      "routing-proxy",
      "nvme-cache"
    ],
    "scope": [
      "pkg/api/warm.go"
    ]
  },
  {
    "id": "list-namespaces-endpoint",
    "category": "api",
    "description": "Implement GET /v1/namespaces endpoint with pagination",
    "steps": [
      "Test endpoint lists namespaces",
      "Verify cursor parameter for pagination",
      "Test prefix parameter for filtering",
      "Verify page_size parameter (default 100, max 1000)",
      "Test response includes namespaces array and next_cursor"
    ],
    "completed": true,
    "depends_on": [
      "namespace-state-management",
      "object-store-abstraction"
    ],
    "scope": [
      "pkg/api/namespaces.go"
    ]
  },
  {
    "id": "delete-namespace-endpoint",
    "category": "api",
    "description": "Implement DELETE /v2/namespaces/:namespace endpoint",
    "steps": [
      "Test endpoint returns 200 on success",
      "Verify tombstone.json written with deletion timestamp",
      "Test state.json updated with tombstoned=true",
      "Verify subsequent reads/writes return 404 'namespace deleted'",
      "Test deletion is irreversible"
    ],
    "completed": true,
    "depends_on": [
      "namespace-state-management"
    ],
    "scope": [
      "pkg/api/delete.go"
    ]
  },
  {
    "id": "delete-namespace-gc",
    "category": "functional",
    "description": "Implement background GC for deleted namespaces",
    "steps": [
      "Test background GC deletes namespace objects",
      "Verify WAL and index objects cleaned up",
      "Test tombstone preserved for fast rejection"
    ],
    "completed": true,
    "depends_on": [
      "delete-namespace-endpoint"
    ],
    "scope": [
      "internal/gc/"
    ]
  },
  {
    "id": "recall-debug-endpoint",
    "category": "api",
    "description": "Implement POST /v1/namespaces/:namespace/_debug/recall endpoint",
    "steps": [
      "Test endpoint samples num vectors",
      "Verify ANN and exhaustive top_k compared",
      "Test avg_recall, avg_ann_count, avg_exhaustive_count returned"
    ],
    "completed": true,
    "depends_on": [
      "vector-query-ann-path"
    ],
    "scope": [
      "pkg/api/recall.go"
    ]
  },
  {
    "id": "debug-state-endpoint",
    "category": "api",
    "description": "Implement GET /_debug/state/:namespace endpoint",
    "steps": [
      "Test endpoint returns namespace state",
      "Verify gated behind admin auth"
    ],
    "completed": true,
    "depends_on": [
      "namespace-state-management"
    ],
    "scope": [
      "pkg/api/debug.go"
    ]
  },
  {
    "id": "debug-cache-endpoint",
    "category": "api",
    "description": "Implement GET /_debug/cache/:namespace endpoint",
    "steps": [
      "Test endpoint returns cache status for namespace",
      "Verify gated behind admin auth"
    ],
    "completed": true,
    "depends_on": [
      "nvme-cache",
      "ram-cache"
    ],
    "scope": [
      "pkg/api/debug.go"
    ]
  },
  {
    "id": "debug-wal-endpoint",
    "category": "api",
    "description": "Implement GET /_debug/wal/:namespace endpoint",
    "steps": [
      "Test endpoint returns WAL entries from from_seq",
      "Verify gated behind admin auth"
    ],
    "completed": true,
    "depends_on": [
      "wal-commit-protocol"
    ],
    "scope": [
      "pkg/api/debug.go"
    ]
  },
  {
    "id": "export-via-pagination",
    "category": "functional",
    "description": "Implement export via paginated query by id",
    "steps": [
      "Test query with rank_by [\"id\", \"asc\"] and limit",
      "Verify filter [\"id\", \"Gt\", last_id] for next page",
      "Test continue until fewer than limit results"
    ],
    "completed": true,
    "depends_on": [
      "query-order-by-attribute"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "http-status-codes",
    "category": "api",
    "description": "Implement all required HTTP status codes",
    "steps": [
      "Test 200 for success",
      "Test 202 for query depending on building index",
      "Test 400 for invalid request/schema/types/duplicate IDs",
      "Test 401/403 for authentication errors",
      "Test 404 for namespace not found",
      "Test 413 for payload too large",
      "Test 429 for rate limiting/backpressure",
      "Test 500 for internal server error",
      "Test 503 for object store failures/strong query with disable_backpressure"
    ],
    "completed": true,
    "depends_on": [
      "api-scaffolding"
    ],
    "scope": [
      "pkg/api/"
    ]
  },
  {
    "id": "error-response-format",
    "category": "api",
    "description": "Implement error response format for all endpoints",
    "steps": [
      "Verify all errors return {\"status\":\"error\",\"error\":\"...\"}",
      "Test error messages are descriptive"
    ],
    "completed": true,
    "depends_on": [
      "api-scaffolding"
    ],
    "scope": [
      "pkg/api/"
    ]
  },
  {
    "id": "failure-object-store-unavailable",
    "category": "functional",
    "description": "Handle object storage unavailable failures",
    "steps": [
      "Test writes fail with 503 when object store unavailable",
      "Verify strong queries fail when snapshot cannot be refreshed",
      "Test eventual queries may serve from cache if not too stale"
    ],
    "completed": true,
    "depends_on": [
      "object-store-abstraction"
    ],
    "scope": [
      "internal/"
    ]
  },
  {
    "id": "failure-partial-wal-commit",
    "category": "functional",
    "description": "Handle partial WAL commit (WAL uploaded but state update failed)",
    "steps": [
      "Test writer retries state CAS after WAL upload",
      "Verify repair task can detect highest contiguous WAL seq",
      "Test repair task advances state head_seq safely",
      "Verify staleness bounded to target 60s"
    ],
    "completed": true,
    "depends_on": [
      "wal-commit-protocol"
    ],
    "scope": [
      "internal/wal/"
    ]
  },
  {
    "id": "failure-node-churn",
    "category": "functional",
    "description": "Handle node churn and routing changes",
    "steps": [
      "Test requests can be served by any node",
      "Verify strong consistency maintained after routing change",
      "Test eventual may be briefly stale until refresh"
    ],
    "completed": true,
    "depends_on": [
      "routing-proxy"
    ],
    "scope": [
      "internal/routing/"
    ]
  },
  {
    "id": "limits-enforcement",
    "category": "functional",
    "description": "Enforce all documented limits",
    "steps": [
      "Test max upsert batch 256MB",
      "Verify max 1 batch/s per namespace",
      "Test 2GB unindexed cap",
      "Verify query concurrency limit 16",
      "Test max multi-query 16",
      "Verify max limit/top_k 10,000",
      "Test max 64 byte IDs",
      "Verify max 128 char attribute names"
    ],
    "completed": true,
    "depends_on": [
      "api-scaffolding"
    ],
    "scope": [
      "internal/"
    ]
  },
  {
    "id": "logging-structured",
    "category": "infrastructure",
    "description": "Implement structured JSON logging",
    "steps": [
      "Test logs are structured JSON",
      "Verify request_id, namespace, endpoint logged",
      "Test cache temperature logged",
      "Verify timings (server_total_ms, query_execution_ms) logged"
    ],
    "completed": true,
    "depends_on": [
      "api-scaffolding"
    ],
    "scope": [
      "internal/logging/"
    ]
  },
  {
    "id": "metrics-prometheus",
    "category": "infrastructure",
    "description": "Implement Prometheus metrics",
    "steps": [
      "Test per-namespace query concurrency metric",
      "Verify tail bytes / unindexed bytes metric",
      "Test cache hits/misses metric",
      "Verify index lag metric (wal_head - indexed_wal_seq)",
      "Test global object store ops and latency",
      "Verify WAL commit latency metric"
    ],
    "completed": true,
    "depends_on": [
      "project-setup"
    ],
    "scope": [
      "internal/metrics/"
    ]
  },
  {
    "id": "format-versioning",
    "category": "infrastructure",
    "description": "Implement format versioning for all on-disk/on-object formats",
    "steps": [
      "Verify format_version in WAL entries",
      "Test format_version in index manifests",
      "Verify format_version in state.json"
    ],
    "completed": true,
    "depends_on": [
      "wal-entry-format",
      "index-manifest-format"
    ],
    "scope": [
      "internal/"
    ]
  },
  {
    "id": "upgrade-strategy",
    "category": "infrastructure",
    "description": "Implement safe upgrade strategy (N-1 version compatibility)",
    "steps": [
      "Test query nodes can read N-1 format versions",
      "Verify indexer can be configured to write new or old format",
      "Test GC of old format segments after retention window"
    ],
    "completed": true,
    "depends_on": [
      "format-versioning"
    ],
    "scope": [
      "internal/"
    ]
  },
  {
    "id": "gc-orphan-objects",
    "category": "functional",
    "description": "Implement GC for orphan objects",
    "steps": [
      "Test orphan objects (not referenced by manifest) are GCed",
      "Verify minimum retention time (24h) before deletion",
      "Test gc/orphan_scan_marker.json tracking"
    ],
    "completed": true,
    "depends_on": [
      "index-publish-protocol"
    ],
    "scope": [
      "internal/gc/"
    ]
  },
  {
    "id": "test-unit-schema",
    "category": "testing",
    "description": "Implement unit tests for schema inference and type checking",
    "steps": [
      "Test schema inference for all supported types",
      "Verify type checking rejects invalid types",
      "Test deterministic schema inference"
    ],
    "completed": true,
    "depends_on": [
      "schema-type-system"
    ],
    "scope": [
      "internal/schema/"
    ]
  },
  {
    "id": "test-unit-filter",
    "category": "testing",
    "description": "Implement unit tests for filter AST evaluation",
    "steps": [
      "Test all filter operators",
      "Verify null semantics (Eq null matches missing)",
      "Test nested boolean operators"
    ],
    "completed": true,
    "depends_on": [
      "filter-evaluation"
    ],
    "scope": [
      "internal/filter/"
    ]
  },
  {
    "id": "test-unit-rankby",
    "category": "testing",
    "description": "Implement unit tests for rank_by expression evaluation",
    "steps": [
      "Test Sum/Max/Product operators",
      "Verify filter boost yields 1 or 0",
      "Test BM25 score computation"
    ],
    "completed": true,
    "depends_on": [
      "bm25-operators"
    ],
    "scope": [
      "internal/query/"
    ]
  },
  {
    "id": "test-unit-vector-encoding",
    "category": "testing",
    "description": "Implement unit tests for vector encoding roundtrip",
    "steps": [
      "Test base64 float32 little-endian roundtrip",
      "Verify float array encoding/decoding"
    ],
    "completed": true,
    "depends_on": [
      "vector-config"
    ],
    "scope": [
      "internal/vector/"
    ]
  },
  {
    "id": "test-golden-api",
    "category": "testing",
    "description": "Implement golden API tests with fixed dataset and queries",
    "steps": [
      "Create fixed dataset for golden tests",
      "Add golden files with expected JSON responses",
      "Test include/exclude attributes",
      "Test limit and aggregation responses",
      "Test multi-query response layout"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic",
      "write-api-basic"
    ],
    "scope": [
      "tests/golden/"
    ]
  },
  {
    "id": "test-simulation-deterministic",
    "category": "testing",
    "description": "Implement deterministic simulation tests",
    "steps": [
      "Create in-memory deterministic object store",
      "Implement deterministic scheduler",
      "Test concurrent writes and CAS retries",
      "Simulate node crashes between WAL upload and state update",
      "Test indexer crashes mid-build",
      "Verify monotonic WAL seq invariant",
      "Test snapshot correctness for strong reads"
    ],
    "completed": true,
    "depends_on": [
      "object-store-abstraction",
      "wal-commit-protocol"
    ],
    "scope": [
      "tests/simulation/"
    ]
  },
  {
    "id": "test-fault-injection",
    "category": "testing",
    "description": "Implement fault injection tests",
    "steps": [
      "Test transient 500 errors from object store",
      "Test timeout errors",
      "Test partial reads",
      "Verify strong queries fail loudly when required",
      "Test eventual queries degrade gracefully",
      "Verify background repair restores state"
    ],
    "completed": true,
    "depends_on": [
      "object-store-abstraction"
    ],
    "scope": [
      "tests/fault/"
    ]
  },
  {
    "id": "test-compat-suite",
    "category": "testing",
    "description": "Implement compatibility test suite against turbopuffer semantics",
    "steps": [
      "Test documented request shapes",
      "Verify HTTP status codes (400/401/202/429)",
      "Test response field presence/shape",
      "Verify Eq null matches missing semantics"
    ],
    "completed": true,
    "depends_on": [
      "http-status-codes",
      "error-response-format"
    ],
    "scope": [
      "tests/compat/"
    ]
  },
  {
    "id": "test-compat-harness-turbopuffer",
    "category": "testing",
    "description": "Implement optional compatibility harness against turbopuffer API",
    "steps": [
      "Run golden tests against turbopuffer when API key available",
      "Compare success/failure behavior",
      "Test ordering semantics",
      "Verify rows_remaining behavior",
      "Allow recall tolerance for ANN comparisons"
    ],
    "completed": true,
    "depends_on": [
      "test-compat-suite"
    ],
    "scope": [
      "tests/compat/"
    ]
  },
  {
    "id": "single-binary-subcommands",
    "category": "infrastructure",
    "description": "Implement single binary with subcommands (query, indexer, all-in-one)",
    "steps": [
      "Test 'vex query' starts query node",
      "Test 'vex indexer' starts indexer node",
      "Test 'vex serve' or default starts all-in-one mode",
      "Verify configuration loading for each mode"
    ],
    "completed": true,
    "depends_on": [
      "project-setup"
    ],
    "scope": [
      "cmd/vex/"
    ]
  },
  {
    "id": "local-dev-minio",
    "category": "infrastructure",
    "description": "Support local development with MinIO",
    "steps": [
      "Verify MinIO can be started for local dev",
      "Test Vex connects to local MinIO",
      "Verify all operations work with MinIO backend"
    ],
    "completed": true,
    "depends_on": [
      "object-store-abstraction"
    ],
    "scope": [
      "scripts/",
      "docker-compose.yml"
    ]
  },
  {
    "id": "config-management",
    "category": "infrastructure",
    "description": "Implement configuration management",
    "steps": [
      "Test config loading from file",
      "Verify environment variable overrides",
      "Test object store connection config",
      "Verify cache size budget config",
      "Test membership/routing config"
    ],
    "completed": true,
    "depends_on": [
      "project-setup"
    ],
    "scope": [
      "internal/config/"
    ]
  },
  {
    "id": "compat-mode-flag",
    "category": "functional",
    "description": "Implement compat_mode flag for strict turbopuffer compatibility",
    "steps": [
      "Test compat_mode=turbopuffer rejects dot_product metric",
      "Verify Vex-only extensions disabled in compat mode"
    ],
    "completed": true,
    "depends_on": [
      "config-management"
    ],
    "scope": [
      "internal/config/"
    ]
  },
  {
    "id": "guardrails-per-namespace",
    "category": "functional",
    "description": "Implement per-namespace guardrails for multi-tenancy",
    "steps": [
      "Test per-namespace in-memory state is demand-loaded",
      "Verify per-namespace state is evictable",
      "Test tail materialization memory caps per namespace",
      "Verify concurrent cold cache fills limited"
    ],
    "completed": true,
    "depends_on": [
      "namespace-state-management"
    ],
    "scope": [
      "internal/"
    ]
  },
  {
    "id": "request-timeout",
    "category": "functional",
    "description": "Implement per-request CPU budget timeouts",
    "steps": [
      "Test query timeout enforcement",
      "Verify write timeout handling"
    ],
    "completed": true,
    "depends_on": [
      "query-api-basic"
    ],
    "scope": [
      "internal/"
    ]
  },
  {
    "id": "cache-temperature-metrics",
    "category": "functional",
    "description": "Implement cache temperature metrics (hot/warm/cold)",
    "steps": [
      "Test hot/warm/cold classification based on hit ratio",
      "Verify metrics exposed for observability"
    ],
    "completed": true,
    "depends_on": [
      "nvme-cache",
      "ram-cache"
    ],
    "scope": [
      "internal/cache/"
    ]
  },
  {
    "id": "vector-incremental-updates",
    "category": "functional",
    "description": "Implement incremental vector updates in WAL tail",
    "steps": [
      "Test new vectors in tail searchable by exhaustive scan",
      "Verify indexer folds tail vectors into IVF segments",
      "Test L0 segments built quickly from WAL"
    ],
    "completed": true,
    "depends_on": [
      "vector-ivf-index",
      "tail-materialization"
    ],
    "scope": [
      "internal/vector/"
    ]
  },
  {
    "id": "segment-compaction",
    "category": "functional",
    "description": "Implement segment compaction (merge L0 into L1/L2)",
    "steps": [
      "Test L0 segments merge into L1",
      "Verify optional reclustering during compaction",
      "Test compaction runs in background"
    ],
    "completed": true,
    "depends_on": [
      "index-lsm-model"
    ],
    "scope": [
      "internal/index/"
    ]
  },
  {
    "id": "fix-routing-proxy-write-query",
    "category": "api",
    "description": "Proxy write and query requests to the home node with fallback to local handling when proxy fails.",
    "steps": [
      "Send a write to a non-home node and verify it proxies to the home node",
      "Simulate proxy failure and verify the request is handled locally without error"
    ],
    "completed": true,
    "scope": [
      "pkg/api/router.go",
      "internal/routing"
    ]
  },
  {
    "id": "fix-vector-filter-index-scan",
    "category": "functional",
    "description": "Ensure vector queries with filters search indexed segments and then merge tail results instead of scanning tail only.",
    "steps": [
      "Index data, run a filtered vector query, and verify results include indexed docs",
      "Verify tail overlay still merges and dedups correctly"
    ],
    "completed": true,
    "scope": [
      "internal/query/handler.go"
    ]
  },
  {
    "id": "fix-order-by-index-scan",
    "category": "functional",
    "description": "Include indexed segments in order-by attribute queries instead of scanning only tail data.",
    "steps": [
      "Index data, run rank_by order-by query, and confirm results include indexed docs",
      "Verify $dist is omitted and ordering is correct across segments and tail"
    ],
    "completed": true,
    "scope": [
      "internal/query/handler.go"
    ]
  },
  {
    "id": "fix-bm25-index-scan",
    "category": "functional",
    "description": "Include indexed BM25 segments in BM25 queries instead of scanning only tail data.",
    "steps": [
      "Index data with FTS, run a BM25 query, and confirm indexed docs are returned",
      "Verify tail overlay still applies with correct scoring"
    ],
    "completed": true,
    "scope": [
      "internal/query/handler.go",
      "internal/fts"
    ]
  },
  {
    "id": "enforce-strong-query-backpressure",
    "category": "functional",
    "description": "Return HTTP 503 for strong queries when disable_backpressure=true and unindexed bytes exceed 2GB using namespace state.",
    "steps": [
      "Set namespace state to disable_backpressure with unindexed_bytes > 2GB and run a strong query to verify 503",
      "Verify eventual queries still return results in the same state"
    ],
    "completed": true,
    "scope": [
      "pkg/api/router.go",
      "internal/query/handler.go"
    ]
  },
  {
    "id": "fix-list-namespaces-catalog",
    "category": "functional",
    "description": "List namespaces from catalog objects rather than scanning state.json keys.",
    "steps": [
      "Create namespaces and ensure catalog objects exist",
      "Call list endpoint with prefix/pagination and verify results come from catalog entries"
    ],
    "completed": true,
    "scope": [
      "pkg/api/router.go"
    ]
  },
  {
    "id": "wal-filter-op-metadata",
    "category": "functional",
    "description": "Persist filter-based write metadata in WAL (phase1 snapshot, candidate IDs, filter expression, patch payload) for deterministic replay.",
    "steps": [
      "Execute delete_by_filter and patch_by_filter writes and inspect WAL entry for required metadata",
      "Replay WAL and verify deterministic application"
    ],
    "completed": true,
    "scope": [
      "internal/write/handler.go",
      "internal/wal"
    ]
  },
  {
    "id": "wal-multi-filter-ops",
    "category": "functional",
    "description": "Allow WAL sub-batches to record both delete_by_filter and patch_by_filter operations in the same request.",
    "steps": [
      "Send a request containing both filter ops and verify WAL encodes both",
      "Replay WAL and confirm ordering is preserved"
    ],
    "completed": true,
    "scope": [
      "internal/wal/entry.proto",
      "internal/wal/encoder.go"
    ]
  },
  {
    "id": "wal-deterministic-ordering",
    "category": "functional",
    "description": "Enforce stable sort by docID for mutations to ensure deterministic WAL encoding and last-write-wins ordering.",
    "steps": [
      "Run identical writes twice and confirm WAL bytes are identical",
      "Verify same-ID mutations preserve phase ordering"
    ],
    "completed": true,
    "scope": [
      "internal/wal/encoder.go",
      "internal/write/handler.go"
    ]
  },
  {
    "id": "wal-unindexed-bytes-logical",
    "category": "functional",
    "description": "Track bytes_unindexed_est using logical bytes written rather than compressed WAL size.",
    "steps": [
      "Commit a write and verify bytes_unindexed_est increases by logical payload size",
      "Confirm backpressure triggers at the expected logical threshold"
    ],
    "completed": true,
    "scope": [
      "internal/wal/committer.go",
      "internal/namespace/manager.go"
    ]
  },
  {
    "id": "wal-key-zero-pad",
    "category": "functional",
    "description": "Zero-pad WAL object keys to match the specified storage layout.",
    "steps": [
      "Commit a WAL entry and verify key format is wal/00000000000000000001.wal.zst",
      "Confirm listing order remains correct with zero padding"
    ],
    "completed": true,
    "scope": [
      "internal/wal/encoder.go"
    ]
  },
  {
    "id": "test-wal-filter-op-metadata",
    "category": "test",
    "description": "Add tests that assert WAL records include filter op metadata (phase1 snapshot, candidate IDs, filter/patch JSON).",
    "steps": [
      "Add unit test for delete_by_filter WAL metadata",
      "Add unit test for patch_by_filter WAL metadata"
    ],
    "completed": true,
    "scope": [
      "internal/write",
      "internal/wal"
    ]
  },
  {
    "id": "write-filter-op-requires-tail",
    "category": "functional",
    "description": "Return an error when delete_by_filter or patch_by_filter cannot execute due to missing tail/snapshot state instead of silently no-op.",
    "steps": [
      "Disable tail store and issue delete_by_filter to verify a 5xx/400 error",
      "Verify normal execution still succeeds when tail is available"
    ],
    "completed": true,
    "scope": [
      "internal/write/handler.go"
    ]
  },
  {
    "id": "write-conditional-requires-snapshot",
    "category": "functional",
    "description": "Evaluate conditional writes against a consistent snapshot and error when snapshot data is unavailable, instead of bypassing conditions.",
    "steps": [
      "Disable tail/snapshot and send conditional upsert/patch/delete and verify error",
      "Enable snapshot and verify conditions apply correctly"
    ],
    "completed": true,
    "scope": [
      "internal/write/handler.go"
    ]
  },
  {
    "id": "write-backpressure-include-incoming",
    "category": "functional",
    "description": "Include incoming write size when checking backpressure so requests that would exceed 2GB are rejected.",
    "steps": [
      "Set bytes_unindexed_est near 2GB and send a write that crosses the threshold to verify 429",
      "Verify smaller writes below threshold succeed"
    ],
    "completed": true,
    "scope": [
      "internal/write/handler.go"
    ]
  },
  {
    "id": "write-schema-inference",
    "category": "functional",
    "description": "Infer schema from write data and record inferred types in WAL for deterministic replay.",
    "steps": [
      "Write documents without explicit schema and verify schema is inferred and persisted",
      "Replay WAL and verify schema matches original inference"
    ],
    "completed": true,
    "scope": [
      "internal/write/handler.go",
      "internal/schema"
    ]
  },
  {
    "id": "write-patch-missing-not-counted",
    "category": "functional",
    "description": "Do not count patches to missing IDs in rows_patched/rows_affected as they must be ignored.",
    "steps": [
      "Patch a missing ID and verify counts remain unchanged",
      "Patch an existing ID and verify counts increment correctly"
    ],
    "completed": true,
    "scope": [
      "internal/write/handler.go",
      "internal/write/handler_test.go"
    ]
  },
  {
    "id": "write-batcher-rate-limit",
    "category": "functional",
    "description": "Enforce at most one WAL entry per second per namespace even under size-triggered flushes.",
    "steps": [
      "Generate concurrent writes and verify only one WAL entry per second is committed",
      "Confirm batching still respects size limits without exceeding rate"
    ],
    "completed": true,
    "scope": [
      "internal/write/batcher.go"
    ]
  },
  {
    "id": "query-eventual-tail-cap-bm25-composite",
    "category": "functional",
    "description": "Apply the 128MiB tail cap to eventual BM25 and composite rank_by queries.",
    "steps": [
      "Run eventual BM25 query with tail larger than 128MiB and verify cap is enforced",
      "Run eventual composite rank_by query and verify the same cap behavior"
    ],
    "completed": true,
    "scope": [
      "internal/query/handler.go"
    ]
  },
  {
    "id": "query-multiq-index-rebuild-202",
    "category": "functional",
    "description": "Return HTTP 202 for multi-query requests when any subquery depends on an index that is rebuilding.",
    "steps": [
      "Configure pending_rebuilds and run multi-query to verify 202 response",
      "Verify single-query behavior remains unchanged"
    ],
    "completed": true,
    "scope": [
      "internal/query/handler.go"
    ]
  },
  {
    "id": "tail-refresh-missing-wal-error",
    "category": "functional",
    "description": "Fail strong queries when a WAL object referenced by state is missing instead of silently skipping it.",
    "steps": [
      "Simulate missing WAL object for a strong query and verify failure response",
      "Verify eventual queries still degrade gracefully where allowed"
    ],
    "completed": true,
    "scope": [
      "internal/tail/store.go"
    ]
  },
  {
    "id": "tail-cap-compressed-bytes",
    "category": "functional",
    "description": "Use compressed WAL byte sizes for eventual tail window accounting even for in-memory entries.",
    "steps": [
      "Add WAL entries with known compressed sizes and verify tail cap calculation uses compressed bytes",
      "Confirm tail selection order remains newest-first"
    ],
    "completed": true,
    "scope": [
      "internal/tail/store.go"
    ]
  },
  {
    "id": "test-eventual-tail-cap-bm25-composite",
    "category": "test",
    "description": "Add tests that assert eventual tail-cap behavior for BM25 and composite rank_by queries.",
    "steps": [
      "Add BM25 tail-cap test",
      "Add composite rank_by tail-cap test"
    ],
    "completed": true,
    "scope": [
      "internal/query"
    ]
  },
  {
    "id": "vector-f16-support",
    "category": "functional",
    "description": "Add f16 vector support in IVF build/read paths with correct byte sizing.",
    "steps": [
      "Index f16 vectors and verify IVF segment sizes and reads are correct",
      "Run vector query against f16 index and verify distances are correct"
    ],
    "completed": true,
    "scope": [
      "internal/vector/ivf.go",
      "internal/index/reader.go"
    ]
  },
  {
    "id": "vector-query-dimension-validate",
    "category": "functional",
    "description": "Validate query vector dimensionality against schema and reject mismatches.",
    "steps": [
      "Submit a vector query with incorrect dims and verify HTTP 400",
      "Submit correct dims and verify normal results"
    ],
    "completed": true,
    "scope": [
      "internal/index/reader.go",
      "internal/query/handler.go"
    ]
  },
  {
    "id": "indexer-wal-gap-advance",
    "category": "functional",
    "description": "Prevent indexer from advancing indexed_wal_seq past the last readable WAL entry when WAL objects are missing.",
    "steps": [
      "Simulate a missing WAL object and verify indexed_wal_seq does not advance past it",
      "Verify segment end_wal_seq matches the last processed WAL"
    ],
    "completed": true,
    "scope": [
      "internal/indexer/indexer.go",
      "internal/indexer/l0_builder.go"
    ]
  },
  {
    "id": "indexer-support-uuid-string-ids",
    "category": "functional",
    "description": "Index vector documents with UUID and string IDs instead of skipping them.",
    "steps": [
      "Write UUID/string IDs with vectors and verify they appear in indexed segments",
      "Query those IDs and verify results include them"
    ],
    "completed": true,
    "scope": [
      "internal/indexer/l0_builder.go"
    ]
  },
  {
    "id": "indexer-tombstones",
    "category": "functional",
    "description": "Record delete tombstones in L0 vector segments so older segments do not resurface deleted docs.",
    "steps": [
      "Delete a doc that exists in older segments and verify it is excluded after indexing",
      "Inspect segment metadata to confirm tombstone persistence"
    ],
    "completed": true,
    "scope": [
      "internal/indexer/l0_builder.go"
    ]
  },
  {
    "id": "indexer-manifest-conditional-write",
    "category": "functional",
    "description": "Write index manifests with conditional semantics to prevent concurrent overwrite and preserve immutability.",
    "steps": [
      "Attempt concurrent manifest writes and verify conflicts are detected",
      "Confirm published manifest references only fully uploaded objects"
    ],
    "completed": true,
    "scope": [
      "internal/indexer/l0_builder.go",
      "internal/index"
    ]
  },
  {
    "id": "fts-segment-honor-updates",
    "category": "functional",
    "description": "Apply patches and deletes (tombstones) when building FTS segments so removed/updated docs do not persist.",
    "steps": [
      "Patch and delete docs then rebuild FTS segment and verify search results reflect changes",
      "Verify tombstones are applied during segment build"
    ],
    "completed": true,
    "scope": [
      "internal/fts/segment.go"
    ]
  },
  {
    "id": "test-indexer-non-u64-ids",
    "category": "test",
    "description": "Add indexer tests for UUID and string IDs in WAL-based vector indexing.",
    "steps": [
      "Add test for UUID ID vector indexing",
      "Add test for string ID vector indexing"
    ],
    "completed": true,
    "scope": [
      "internal/indexer"
    ]
  },
  {
    "id": "cache-init-serve-path",
    "category": "performance",
    "description": "Initialize NVMe/RAM caches and cache warmer in the serve path so caching and warm hints are effective.",
    "steps": [
      "Start server and verify caches are constructed and injected into query/tail handlers",
      "Call warm-cache endpoint and confirm prefetch tasks run"
    ],
    "completed": true,
    "scope": [
      "cmd/vex/serve/serve.go",
      "pkg/api/router.go"
    ]
  },
  {
    "id": "warm-cache-response-empty",
    "category": "api",
    "description": "Return an empty success payload for warm-cache hint endpoint instead of a JSON body.",
    "steps": [
      "Call warm-cache endpoint and verify empty response body with 200 status"
    ],
    "completed": true,
    "scope": [
      "pkg/api/router.go"
    ]
  },
  {
    "id": "ram-cache-per-namespace-cap-config",
    "category": "functional",
    "description": "Expose and enforce per-namespace RAM cache caps via configuration defaults.",
    "steps": [
      "Set per-namespace cap in config and verify enforcement under load",
      "Verify default cap is applied when config is unset"
    ],
    "completed": true,
    "scope": [
      "internal/cache/memory.go",
      "internal/config/config.go"
    ]
  },
  {
    "id": "routing-self-addr-normalization",
    "category": "functional",
    "description": "Normalize node addresses so home-node detection works when listen addr and membership addr use different formats.",
    "steps": [
      "Configure listen addr as :8080 and membership addr as localhost:8080 and verify local node is recognized as home",
      "Confirm proxying only happens when node is not home"
    ],
    "completed": true,
    "scope": [
      "internal/config/config.go",
      "internal/routing/rendezvous.go"
    ]
  },
  {
    "id": "guardrails-wireup-runtime",
    "category": "functional",
    "description": "Wire guardrails manager into runtime to enforce per-namespace tail caps and cold-fill limits.",
    "steps": [
      "Enable guardrails config and verify caps are applied at runtime",
      "Simulate concurrent cold fills and verify guardrails limit concurrency"
    ],
    "completed": true,
    "scope": [
      "internal/guardrails",
      "cmd/vex/serve/serve.go"
    ]
  },
  {
    "id": "logging-add-cache-temperature",
    "category": "infra",
    "description": "Include cache_temperature and query_execution_ms in structured request logs.",
    "steps": [
      "Run a query and verify logs include cache_temperature and query_execution_ms fields",
      "Verify server_total_ms remains intact"
    ],
    "completed": true,
    "scope": [
      "internal/logging/middleware.go"
    ]
  },
  {
    "id": "query-mode-objectstore-init",
    "category": "functional",
    "description": "Initialize object store and real namespace state in query-only mode so HTTP endpoints operate on durable storage instead of fallback/test behavior.",
    "steps": [
      "Start `vex query` and verify it loads object store config and can read/write namespace state.json",
      "Run a write+query roundtrip via the query-only server and confirm data persists in object storage"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "cmd/vex/query"
    ]
  },
  {
    "id": "enforce-bearer-auth-required",
    "category": "security",
    "description": "Require Bearer auth for all API endpoints even when AuthToken is unset, returning 401/403 per spec instead of allowing anonymous access.",
    "steps": [
      "Start server with empty AuthToken and confirm requests without Authorization header are rejected",
      "Start server with AuthToken set and confirm only matching Bearer token is accepted"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "pkg/api/router.go"
    ]
  },
  {
    "id": "proxy-gzip-safety",
    "category": "api",
    "description": "Prevent double gzip compression and header mismatches when proxying responses, ensuring gzip is applied exactly once based on client Accept-Encoding.",
    "steps": [
      "Proxy a gzip-capable request and verify Content-Encoding is set only once with correct body",
      "Proxy a non-gzip request and confirm the body is uncompressed and headers are consistent"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "pkg/api/router.go",
      "internal/routing/proxy.go"
    ]
  },
  {
    "id": "filter-conditional-copy-snapshot-full",
    "category": "functional",
    "description": "Evaluate filter-based writes, conditional writes, and copy_from_namespace against a full namespace snapshot (indexed + tail) rather than TailStore-only.",
    "steps": [
      "Create indexed data and verify delete_by_filter/patch_by_filter affect indexed docs",
      "Run conditional writes against indexed docs and verify conditions are evaluated correctly",
      "Run copy_from_namespace and verify all indexed docs are copied"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/write"
    ]
  },
  {
    "id": "wal-putifabsent-conflict-retry",
    "category": "functional",
    "description": "Handle WAL PutIfAbsent conflicts and state CAS retries without advancing state to the wrong WAL key, enforcing seq alignment under concurrency.",
    "steps": [
      "Simulate concurrent writers hitting the same seq and verify state.json only advances to the winning WAL object",
      "Verify a PutIfAbsent conflict does not update state.json with a mismatched wal key"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/write",
      "internal/wal"
    ]
  },
  {
    "id": "test-filter-conditional-copy-indexed",
    "category": "test",
    "description": "Add tests that exercise filter/conditional/copy behaviors against indexed segments (not just tail) to validate full-snapshot semantics.",
    "steps": [
      "Create indexed segments and test delete_by_filter/patch_by_filter on indexed docs",
      "Test conditional upsert/patch/delete against indexed docs",
      "Test copy_from_namespace over indexed source data"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/write"
    ]
  },
  {
    "id": "query-filter-bitmaps-all-segments",
    "category": "functional",
    "description": "Load and merge filter bitmap indexes across all segments so filtered queries include matches from every indexed segment.",
    "steps": [
      "Index data into multiple segments and run filtered queries that match only later segments",
      "Verify results include matches from all segments and tail"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/query/handler.go"
    ]
  },
  {
    "id": "indexer-include-nonvector-docs",
    "category": "functional",
    "description": "Indexer must materialize non-vector upserts into doc segments so non-vector documents remain queryable after WAL tail advances.",
    "steps": [
      "Write documents without vectors, run indexing, and confirm they appear in indexed doc storage",
      "Advance WAL tail past indexed_wal_seq and verify the docs are still returned by queries"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/indexer/l0_builder.go"
    ]
  },
  {
    "id": "indexer-apply-patch-mutations",
    "category": "functional",
    "description": "Apply patch mutations (including filter-based patches) during segment build so indexed segments reflect updates.",
    "steps": [
      "Write docs, apply patch_rows/patch_by_filter, run indexing, and verify indexed results reflect patched fields",
      "Confirm patched docs stay updated after tail advances"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/indexer/l0_builder.go"
    ]
  },
  {
    "id": "indexer-publish-filter-artifacts",
    "category": "functional",
    "description": "Build and publish filter index artifacts (filters.<attr>.rbm) in index segments for filterable attributes.",
    "steps": [
      "Enable filterable attributes, run indexing, and verify filter artifacts are present in segment storage",
      "Run filtered queries and confirm they use the published filter artifacts"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/indexer/l0_builder.go",
      "internal/index"
    ]
  },
  {
    "id": "indexer-distance-metric-per-namespace",
    "category": "functional",
    "description": "Use namespace state distance_metric when building IVF segments so euclidean_squared namespaces are indexed correctly.",
    "steps": [
      "Create a namespace with euclidean_squared, run indexing, and verify IVF config stores/uses that metric",
      "Run vector queries and verify distances match euclidean_squared expectations"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/indexer/l0_builder.go"
    ]
  },
  {
    "id": "compaction-publish-manifest",
    "category": "functional",
    "description": "Persist compaction output by publishing new manifests and updating state.json, with retention-based cleanup of obsolete segments.",
    "steps": [
      "Run compaction and verify a new manifest is written and state.json is updated",
      "Verify queries read compacted segments and old segments are eligible for GC after retention"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/index/compactor.go",
      "internal/index"
    ]
  },
  {
    "id": "test-indexer-nonvector-patch-filter",
    "category": "test",
    "description": "Add indexer tests covering non-vector docs, patch mutations, and filter index artifact creation.",
    "steps": [
      "Test indexing of non-vector-only docs",
      "Test indexing after patch mutations",
      "Test filter artifact creation for filterable attributes"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/indexer",
      "internal/index"
    ]
  },
  {
    "id": "tailstore-spill-and-ram-evict",
    "category": "performance",
    "description": "Implement TailStore RAM limits with spill-to-NVMe and eviction so tail materialization respects tiered storage.",
    "steps": [
      "Configure a low RAM cap, ingest WAL tail, and verify spill files are created on NVMe",
      "Verify RAM usage stays within cap while strong queries still access full tail via spill"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/tail/store.go"
    ]
  },
  {
    "id": "tailstore-strong-read-completeness",
    "category": "functional",
    "description": "Ensure tail guardrails never drop committed WAL entries for strong reads; spill or fetch from object storage instead of rejecting.",
    "steps": [
      "Enable guardrails with low per-namespace cap and verify strong queries still include all committed WAL entries",
      "Verify tail data beyond caps is served via spill/object store rather than dropped"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/tail/store.go"
    ]
  },
  {
    "id": "metrics-cache-hits-per-namespace",
    "category": "infra",
    "description": "Add per-namespace cache hit/miss metrics labels to meet observability requirements.",
    "steps": [
      "Record cache hits/misses for multiple namespaces and verify metrics include namespace labels",
      "Confirm metrics still aggregate correctly by cache_type"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/metrics/metrics.go"
    ]
  },
  {
    "id": "logging-request-metrics-final",
    "category": "infra",
    "description": "Capture RequestMetrics after handlers run so cache_temperature and query_execution_ms fields are logged correctly.",
    "steps": [
      "Run a query that sets cache_temperature and query_execution_ms and verify logs contain updated values",
      "Confirm server_total_ms remains accurate"
    ],
    "completed": true,
    "depends_on": [],
    "scope": [
      "internal/logging/middleware.go"
    ]
  },
  {
    "id": "tests-add-auth-headers",
    "category": "test",
    "description": "Ensure compat/golden/integration HTTP tests send Authorization headers using a configurable API token so they exercise real auth flows.",
    "steps": [
      "Update test helpers to load an API token from env/config and attach Authorization: Bearer headers",
      "Run `go test ./tests/...`",
      "Fix any auth-related failures or mismatched error envelopes",
      "Re-run `go test ./tests/...` to confirm green"
    ],
    "completed": true,
    "scope": [
      "tests/compat",
      "tests/golden",
      "tests/integration"
    ]
  },
  {
    "id": "integration-gzip-coverage",
    "category": "test",
    "description": "Add object-store-backed integration coverage for gzip request bodies and gzip responses across write/query/metadata endpoints.",
    "steps": [
      "Add gzip request/response cases to integration tests (write/query/metadata) using Content-Encoding and Accept-Encoding",
      "Run `go test ./tests/integration -run Gzip`",
      "Fix any handler or proxy gzip issues discovered",
      "Re-run the same integration tests to verify pass"
    ],
    "completed": true,
    "scope": [
      "tests/integration/object_store_test.go"
    ]
  },
  {
    "id": "integration-required-endpoints",
    "category": "test",
    "description": "Add object-store-backed integration tests for list namespaces, delete namespace, warm-cache hint, and recall endpoints.",
    "steps": [
      "Add end-to-end tests that hit list/delete/warm/recall over HTTP with object-store backing",
      "Run `go test ./tests/integration -run Endpoints`",
      "Fix any missing routes or response shape issues",
      "Re-run the same integration tests to verify pass"
    ],
    "completed": true,
    "scope": [
      "tests/integration/object_store_test.go"
    ]
  },
  {
    "id": "integration-wal-cas-idempotency",
    "category": "test",
    "description": "Add object-store-backed integration tests for WAL commit ordering, CAS retries, and request idempotency over HTTP.",
    "steps": [
      "Add integration tests that force CAS retries and duplicate request_id handling while asserting WAL ordering and response reuse",
      "Run `go test ./tests/integration -run WalCAS`",
      "Fix WAL commit/idempotency behavior if failures appear",
      "Re-run the same integration tests to verify pass"
    ],
    "completed": true,
    "scope": [
      "tests/integration",
      "internal/wal",
      "internal/write"
    ]
  },
  {
    "id": "integration-write-backpressure-http",
    "category": "test",
    "description": "Add object-store-backed integration tests for write backpressure behavior and disable_backpressure overrides.",
    "steps": [
      "Add integration tests that drive unindexed_bytes past 2GiB and assert 429/override semantics",
      "Run `go test ./tests/integration -run Backpressure`",
      "Fix HTTP status and state transition issues if failures appear",
      "Re-run the same integration tests to verify pass"
    ],
    "completed": true,
    "scope": [
      "tests/integration",
      "internal/write"
    ]
  },
  {
    "id": "wal-sub-batch-ordering-test",
    "category": "test",
    "description": "Verify WAL sub-batch ordering and contents for batched requests beyond head_seq checks.",
    "steps": [
      "Add a test that batches multiple HTTP write requests and asserts WAL sub-batch order and contents",
      "Run `go test ./internal/write -run BatcherSubBatch`",
      "Fix WAL encoding or batching logic if ordering/content mismatches occur",
      "Re-run the same test to confirm pass"
    ],
    "completed": true,
    "scope": [
      "internal/write/batcher_test.go",
      "internal/wal"
    ]
  },
  {
    "id": "bm25-tail-dedup-id-normalization",
    "category": "bug",
    "description": "Fix BM25 tail/index deduplication by normalizing ID types so tail updates and deletes correctly shadow indexed results.",
    "steps": [
      "Add a regression test that mixes typed string IDs and u64 IDs across indexed and tail data",
      "Fix dedup logic to compare canonical ID representations consistently",
      "Run `go test ./internal/query -run BM25.*Dedup`"
    ],
    "completed": true,
    "scope": [
      "internal/query"
    ]
  },
  {
    "id": "strong-query-backpressure-regression",
    "category": "bug",
    "description": "Enforce strong-query 503 behavior when disable_backpressure is true and unindexed bytes exceed 2GiB, and lock it in with a regression test.",
    "steps": [
      "Add a regression test that sets disable_backpressure and unindexed_bytes > 2GiB and expects 503 for strong queries",
      "Update strong-consistency path to check namespace_flags and wal.bytes_unindexed_est before executing",
      "Run `go test ./internal/query -run StrongBackpressure`"
    ],
    "completed": true,
    "scope": [
      "internal/query",
      "pkg/api"
    ]
  },
  {
    "id": "tail-prune-indexed-entries",
    "category": "bug",
    "description": "Prune tail entries at or below indexed_wal_seq so TailStore represents only unindexed WAL and respects eventual tail caps.",
    "steps": [
      "Add a unit test that refreshes tail then advances indexed_wal_seq and expects older entries to be removed",
      "Implement pruning during refresh or snapshot creation",
      "Run `go test ./internal/tail -run PruneIndexed`"
    ],
    "completed": true,
    "scope": [
      "internal/tail/store.go"
    ]
  },
  {
    "id": "integration-consistency-tail",
    "category": "test",
    "description": "Add integration tests for strong/eventual consistency with tail overlay and 128MiB tail caps.",
    "steps": [
      "Add end-to-end tests that write, index, and query with strong/eventual modes and verify tail inclusion and cap behavior",
      "Run `go test ./tests/integration -run ConsistencyTail`",
      "Fix snapshot/tail handling if failures appear",
      "Re-run the same integration tests to verify pass"
    ],
    "completed": true,
    "scope": [
      "tests/integration",
      "internal/query",
      "internal/tail"
    ]
  },
  {
    "id": "indexer-wire-fts-segments",
    "category": "bug",
    "description": "Wire FTS/BM25 segment building into the L0 indexer pipeline and manifest publishing.",
    "steps": [
      "Add a test that enables full_text_search and verifies FTS artifacts are produced and referenced",
      "Hook FTS build outputs into L0 builder and manifest writer",
      "Run `go test ./internal/indexer -run FTS`"
    ],
    "completed": true,
    "scope": [
      "internal/indexer",
      "internal/fts",
      "internal/index"
    ]
  },
  {
    "id": "indexer-rebuild-ready-gate",
    "category": "bug",
    "description": "Only mark pending_rebuilds ready after the corresponding rebuild artifacts are actually built and published.",
    "steps": [
      "Add a test that enables an index, triggers rebuild, and verifies queries stay 202 until artifacts exist",
      "Update readiness logic to verify artifact presence/version before flipping ready",
      "Run `go test ./internal/indexer -run RebuildReady`"
    ],
    "completed": true,
    "scope": [
      "internal/indexer",
      "internal/index"
    ]
  },
  {
    "id": "indexer-filter-index-nonvector",
    "category": "bug",
    "description": "Build filter indexes from all documents, not just vectorDocs, so filter-only and BM25 queries see complete results.",
    "steps": [
      "Add a test that indexes docs without vectors and verifies filter bitmap coverage includes them",
      "Update L0 builder to include non-vector docs when constructing filter indexes",
      "Run `go test ./internal/indexer -run FilterIndexAllDocs`"
    ],
    "completed": true,
    "scope": [
      "internal/indexer",
      "internal/filter"
    ]
  },
  {
    "id": "integration-bm25-fts",
    "category": "test",
    "description": "Add integration tests for BM25/FTS query flows and readiness gating across indexer \u2192 manifest \u2192 query.",
    "steps": [
      "Add end-to-end tests that enable FTS, index data, and run BM25 queries while validating 202 gating until ready",
      "Run `go test ./tests/integration -run BM25`",
      "Fix indexer/query integration issues if failures appear",
      "Re-run the same integration tests to verify pass"
    ],
    "completed": true,
    "scope": [
      "tests/integration",
      "internal/fts",
      "internal/query",
      "internal/indexer"
    ]
  },
  {
    "id": "disk-cache-pinning-reload",
    "category": "bug",
    "description": "Preserve ObjectKey metadata when reloading disk cache entries so namespace pinning prevents eviction during warming.",
    "steps": [
      "Add a regression test that reloads cache entries and verifies pin matching by namespace prefix",
      "Populate ObjectKey on reload and ensure pin checks use it consistently",
      "Run `go test ./internal/cache -run PinningReload`"
    ],
    "completed": true,
    "scope": [
      "internal/cache/disk.go"
    ]
  },
  {
    "id": "integration-warm-cache-hint",
    "category": "test",
    "description": "Add integration tests for warm-cache hint to verify prefetch and pinning with real object store and caches.",
    "steps": [
      "Add end-to-end tests that call hint_cache_warm and assert warm tasks and pinned cache behavior",
      "Run `go test ./tests/integration -run WarmCache`",
      "Fix warm task or pinning issues if failures appear",
      "Re-run the same integration tests to verify pass"
    ],
    "completed": true,
    "scope": [
      "tests/integration",
      "internal/warmer",
      "internal/cache",
      "pkg/api"
    ]
  },
  {
    "id": "catalog-cleanup-on-delete",
    "category": "bug",
    "description": "Remove namespace catalog entries during delete/GC so deleted namespaces no longer appear in list results.",
    "steps": [
      "Add a test that deletes a namespace and verifies catalog entry removal and list exclusion",
      "Update delete/GC flow to delete catalog keys for tombstoned namespaces",
      "Run `go test ./internal/namespace ./internal/gc -run CatalogCleanup`"
    ],
    "completed": true,
    "scope": [
      "internal/namespace",
      "internal/gc",
      "pkg/api"
    ]
  },
  {
    "id": "integration-delete-list",
    "category": "test",
    "description": "Add integration coverage for delete namespace followed by list namespaces to ensure tombstoned entries are excluded.",
    "steps": [
      "Add end-to-end tests that create, delete, and list namespaces and assert absence",
      "Run `go test ./tests/integration -run DeleteList`",
      "Fix delete/list interactions if failures appear",
      "Re-run the same integration tests to verify pass"
    ],
    "completed": true,
    "scope": [
      "tests/integration",
      "pkg/api"
    ]
  },
  {
    "id": "integration-tests-skip-missing-objectstore-creds",
    "category": "reliability",
    "description": "Skip or gate S3-backed integration tests when object-store credentials are missing to avoid hard-fail in default runs.",
    "steps": [
      "Update integration test setup to detect missing creds and skip with a clear message",
      "Run `go test ./tests/integration` without creds to confirm skip behavior",
      "Run the same tests with creds to confirm they execute normally"
    ],
    "completed": true,
    "scope": [
      "tests/integration/object_store_test.go"
    ]
  },
  {
    "id": "vector-query-topk-heap",
    "category": "performance",
    "description": "Use a bounded top-k heap during ANN cluster scans to avoid materializing all candidate vectors in memory.",
    "steps": [
      "Add tests that fail with current behavior by asserting ANN search does not retain more than O(top_k) candidates",
      "Run `go test ./internal/index -run ANN` and confirm the new tests fail",
      "Implement a top-k heap collector for IVF search and large-cluster streaming paths",
      "Update tests to pass with heap pruning and verify result correctness",
      "Run `go test ./internal/index -run ANN`"
    ],
    "completed": true,
    "scope": [
      "internal/index/reader.go",
      "internal/query/vector_ann_test.go"
    ]
  },
  {
    "id": "vector-query-parallel-range-fetch",
    "category": "performance",
    "description": "Parallelize multi-range cluster fetches to reduce latency on cold cache ANN queries.",
    "steps": [
      "Add tests that fail with current behavior by simulating slow object store reads and asserting parallel fetch completion",
      "Run `go test ./internal/index -run MultiRange` and confirm the new tests fail",
      "Implement bounded parallel fetching for merged ranges with error propagation",
      "Update tests to pass and verify per-range caching semantics remain correct",
      "Run `go test ./internal/index -run MultiRange`"
    ],
    "completed": true,
    "scope": [
      "internal/index/reader.go",
      "internal/index/reader_test.go"
    ]
  },
  {
    "id": "vector-query-large-cluster-streaming",
    "category": "performance",
    "description": "Improve large-cluster streaming to reduce tail latency and allow configurable chunk sizing.",
    "steps": [
      "Add tests that fail with current behavior by covering streaming large clusters with chunked range reads and top-k correctness",
      "Run `go test ./internal/index -run Streaming` and confirm the new tests fail",
      "Make chunk size configurable and validate boundary alignment",
      "Update tests to pass and verify streaming search returns correct top-k results",
      "Run `go test ./internal/index -run Streaming`"
    ],
    "completed": true,
    "scope": [
      "internal/index/reader.go",
      "internal/index/reader_test.go"
    ]
  },
  {
    "id": "vector-query-cache-verification",
    "category": "performance",
    "description": "Verify disk cache effectiveness for ANN cluster ranges across repeated queries.",
    "steps": [
      "Add tests that fail with current behavior by running identical ANN queries twice and asserting cache hit metrics increase",
      "Run `go test ./internal/index -run Cache` and confirm the new tests fail",
      "Expose cache hit/miss counters for ANN cluster range reads",
      "Update tests to pass and confirm cold query uses object store and warm query uses cache",
      "Run `go test ./internal/index -run Cache`"
    ],
    "completed": true,
    "scope": [
      "internal/index/reader.go",
      "internal/cache",
      "internal/metrics"
    ]
  },
  {
    "id": "api-objectstore-failure-503",
    "category": "api",
    "description": "Return HTTP 503 (not 500) for object store/state failures on list namespaces, metadata, warm-cache, delete namespace, and recall endpoints with the standard error envelope.",
    "steps": [
      "Inject an object store failure for each affected endpoint and confirm current status codes are 500",
      "Update error mapping to return 503 with {\"status\":\"error\",\"error\":\"...\"}",
      "Add or update endpoint-level tests to assert 503 on object store failures",
      "Re-run the endpoint tests and verify 503 responses"
    ],
    "completed": true,
    "scope": [
      "pkg/api/router.go"
    ]
  },
  {
    "id": "metadata-approx-stats-nonzero",
    "category": "bug",
    "description": "Populate metadata response with real approx_row_count and approx_logical_bytes instead of zero constants.",
    "steps": [
      "Trace where stats are computed/stored in state or index manifests and confirm they are available",
      "Plumb the actual approx_row_count and approx_logical_bytes into the metadata response",
      "Add a test that writes data, indexes, and validates metadata stats are non-zero",
      "Re-run the test to confirm stats reflect stored values"
    ],
    "completed": true,
    "scope": [
      "pkg/api/router.go",
      "internal/namespace",
      "internal/index"
    ]
  },
  {
    "id": "s3-conditional-put-atomic",
    "category": "bug",
    "description": "Implement S3 PutIfAbsent/PutIfMatch using native conditional headers to ensure atomic CAS semantics.",
    "steps": [
      "Replace Stat+Put race window with PUT using If-None-Match/If-Match headers",
      "Ensure conflicts return a distinct error and are handled by retry logic",
      "Add or update object store tests to simulate concurrent writers and assert no duplicate WAL seqs",
      "Run the object store tests to confirm CAS behavior"
    ],
    "completed": true,
    "scope": [
      "pkg/objectstore/s3.go"
    ]
  },
  {
    "id": "patch-missing-id-snapshot-required",
    "category": "bug",
    "description": "Prevent patch_rows/patch_columns from creating docs when snapshot/tail data is unavailable; require a snapshot or return an error.",
    "steps": [
      "Identify code paths that bypass existence checks when tail snapshot is missing",
      "Change behavior to error (or otherwise ensure missing IDs are ignored) when no snapshot is available",
      "Add a regression test that disables tail/snapshot and patches a missing ID expecting a failure or no-op per spec",
      "Run the write tests to confirm patches do not create missing docs"
    ],
    "completed": true,
    "scope": [
      "internal/write/handler.go",
      "internal/write/batcher.go"
    ]
  },
  {
    "id": "eventual-consistency-ttl-enforcement",
    "category": "bug",
    "description": "Enforce the 60s staleness bound for eventual consistency by refreshing state/tail on expiry.",
    "steps": [
      "Add TTL tracking for eventual snapshots and force refresh when stale > 60s",
      "Add a test that advances time beyond TTL and verifies eventual queries refresh state/tail",
      "Run the query consistency tests to confirm behavior"
    ],
    "completed": true,
    "scope": [
      "internal/query/handler.go",
      "internal/tail"
    ]
  },
  {
    "id": "tail-index-dedup-walseq-compare",
    "category": "bug",
    "description": "Compare WAL sequence when merging tail and index results so older tail versions cannot shadow newer indexed docs.",
    "steps": [
      "Identify merge logic that assumes tail is always newer",
      "Add WAL-seq comparison and choose the highest version per ID",
      "Add a regression test with stale tail vs newer indexed doc to verify last-write-wins",
      "Run the query tests to confirm correct dedup"
    ],
    "completed": true,
    "scope": [
      "internal/query/handler.go"
    ]
  },
  {
    "id": "id-normalization-preserve-string",
    "category": "bug",
    "description": "Preserve string IDs that are numeric as strings instead of coercing to u64.",
    "steps": [
      "Update ID parsing to keep JSON string inputs as string IDs even if numeric",
      "Add tests for string \"42\" and numeric 42 to ensure they remain distinct IDs",
      "Run document ID tests to confirm separation"
    ],
    "completed": true,
    "scope": [
      "internal/document/id.go",
      "internal/document"
    ]
  },
  {
    "id": "filter-null-vs-missing-distinction",
    "category": "bug",
    "description": "Differentiate explicit null from missing attributes in filter evaluation per spec.",
    "steps": [
      "Adjust filter evaluation to track explicit null vs missing attributes separately",
      "Update Eq/NotEq null semantics to match spec with explicit null preserved",
      "Add tests that distinguish missing vs explicit null behavior",
      "Run filter tests to confirm updated semantics"
    ],
    "completed": true,
    "scope": [
      "internal/filter/filter.go",
      "internal/filter"
    ]
  },
  {
    "id": "segment-docs-columnar-zstd",
    "category": "bug",
    "description": "Store docs in segments as zstd-compressed columnar format for docs.col.zst instead of raw JSON.",
    "steps": [
      "Implement columnar doc encoding and zstd compression for docs.col.zst writes",
      "Update segment reader to decode the new format",
      "Add a test that writes and reads a segment and validates format and compression",
      "Run indexer/segment tests to confirm compatibility"
    ],
    "completed": true,
    "scope": [
      "internal/indexer/l0_builder.go",
      "internal/index/segment.go"
    ]
  },
  {
    "id": "fts-artifact-key-format",
    "category": "bug",
    "description": "Publish FTS artifacts using spec-compliant keys fts.<field>.bm25 instead of fts/<attr>.idx.",
    "steps": [
      "Update FTS segment writer to use the correct key naming",
      "Update any readers/manifest references to match the new keys",
      "Add a test to assert manifest fts_keys use fts.<field>.bm25",
      "Run FTS/indexer tests to confirm behavior"
    ],
    "completed": true,
    "scope": [
      "internal/index/segment.go",
      "internal/fts"
    ]
  },
  {
    "id": "fts-language-stemming-options",
    "category": "bug",
    "description": "Apply full_text_search options (language, stemming, remove_stopwords, ascii_folding) in tokenization.",
    "steps": [
      "Wire tokenizer to respect language-specific stopwords and stemming settings",
      "Honor remove_stopwords and ascii_folding config in tokenization pipeline",
      "Add tests for non-English language and stemming toggles",
      "Run FTS tests to confirm option effects"
    ],
    "completed": true,
    "scope": [
      "internal/fts/tokenizer.go",
      "internal/fts"
    ]
  },
  {
    "id": "disk-cache-namespace-metrics-fix",
    "category": "observability",
    "description": "Attribute disk cache hits/misses to the correct namespace by parsing keys under vex/namespaces/<namespace>/...",
    "steps": [
      "Fix namespace extraction logic for object keys",
      "Add a test that records cache events for multiple namespaces and verifies labels",
      "Run cache metrics tests to confirm per-namespace attribution"
    ],
    "completed": true,
    "scope": [
      "internal/cache/disk.go",
      "internal/metrics"
    ]
  },
  {
    "id": "warm-cache-prefetch-bounds",
    "category": "performance",
    "description": "Limit warm-cache hint prefetch to centroids, cluster offsets, doc column headers, and hottest filter bitmaps instead of full object reads.",
    "steps": [
      "Replace io.ReadAll on large objects with bounded header/prefix reads",
      "Implement selection of hottest filter bitmaps only",
      "Add a test to assert warm hint does not read full docs/bitmaps",
      "Run warm-cache tests to confirm bounded prefetch"
    ],
    "completed": true,
    "scope": [
      "internal/warmer/warmer.go"
    ]
  },
  {
    "id": "secure-disable-test-state-endpoint",
    "category": "security",
    "description": "Remove or admin-gate the unauthenticated POST /_test/state endpoint so it cannot mutate state in production builds.",
    "steps": [
      "Locate the /_test/state route and either remove it or guard it behind admin auth",
      "Add a test that unauthenticated requests to /_test/state return 401/403",
      "Run the relevant API tests and confirm the endpoint is no longer publicly accessible"
    ],
    "completed": true,
    "scope": [
      "pkg/api/router.go"
    ]
  },
  {
    "id": "enforce-post-gzip-size-limit",
    "category": "api",
    "description": "Enforce the 256MB request size limit after gzip decompression to prevent oversized writes from bypassing limits.",
    "steps": [
      "Move size enforcement to wrap the decompressed reader and reject when inflated size exceeds 256MB",
      "Add a test that sends a small gzip body that inflates beyond 256MB and expects 413",
      "Run the write API tests and verify both compressed and uncompressed limits are enforced"
    ],
    "completed": true,
    "scope": [
      "pkg/api/router.go"
    ]
  },
  {
    "id": "configuration-reference",
    "category": "docs",
    "description": "Create a configuration reference covering JSON schema, env overrides, defaults, and object store options.",
    "steps": [
      "Review `internal/config/config.go` and `cmd/vex/*.go` to list config fields, defaults, and overrides.",
      "Document each config section (mode, listen_addr, auth/admin tokens, compat_mode, object_store, cache, membership, indexer, guardrails, timeout) with meanings and defaults.",
      "Add a table of `VEX_*` environment variables mapped to config fields plus minimal and full example configs.",
      "Note supported object store types and required fields using `pkg/objectstore/store.go`."
    ],
    "scope": [
      "docs/configuration.md",
      "internal/config/config.go",
      "cmd/vex/serve/serve.go",
      "cmd/vex/query/query.go",
      "cmd/vex/indexer/indexer.go",
      "pkg/objectstore/store.go"
    ],
    "completed": true
  },
  {
    "id": "api-overview",
    "category": "docs",
    "description": "Document API conventions including auth, compression, error envelope, status codes, and global limits.",
    "steps": [
      "Extract auth, gzip handling, and body size enforcement from `pkg/api/router.go`.",
      "Use `pkg/api/errors.go` and `SPEC.md` to list error envelope and status codes.",
      "Write `docs/api/overview.md` with headers, request/response conventions, and limits plus a sample error JSON."
    ],
    "scope": [
      "docs/api/overview.md",
      "pkg/api/router.go",
      "pkg/api/errors.go",
      "SPEC.md"
    ],
    "completed": true
  },
  {
    "id": "api-write",
    "category": "docs",
    "description": "Document the write endpoint schema, mutation ordering, constraints, and response format.",
    "steps": [
      "Read `internal/write/handler.go` for WriteRequest/WriteResponse fields, limits, and mutation ordering.",
      "Document accepted ID formats and constraints using `internal/document/id.go` and filter syntax from `internal/filter/filter.go`.",
      "Include JSON examples for row and column writes, delete_by_filter, patch_by_filter, copy_from_namespace, schema updates, and backpressure flags.",
      "Confirm the endpoint path and auth requirements from `pkg/api/router.go`."
    ],
    "depends_on": [
      "api-overview"
    ],
    "scope": [
      "docs/api/write.md",
      "internal/write/handler.go",
      "internal/document/id.go",
      "internal/filter/filter.go",
      "pkg/api/router.go",
      "SPEC.md"
    ],
    "completed": true
  },
  {
    "id": "api-query",
    "category": "docs",
    "description": "Document query endpoint parameters, rank_by variants, filters, aggregations, and responses.",
    "steps": [
      "Use `internal/query/handler.go` and `internal/query/request.go` to list fields, defaults, and validation rules.",
      "Describe rank_by formats (vector, BM25, attr order, composite), limit/top_k, per, include/exclude attributes, vector_encoding, consistency, and multi-query.",
      "Explain filter syntax using `internal/filter/filter.go` and provide example requests and responses.",
      "Verify endpoint path and auth requirements via `pkg/api/router.go`."
    ],
    "depends_on": [
      "api-overview"
    ],
    "scope": [
      "docs/api/query.md",
      "internal/query/handler.go",
      "internal/query/request.go",
      "internal/filter/filter.go",
      "pkg/api/router.go"
    ],
    "completed": true
  },
  {
    "id": "api-namespace-ops",
    "category": "docs",
    "description": "Document namespace metadata, list, warm-cache, and delete endpoints with request/response fields.",
    "steps": [
      "Inspect `pkg/api/router.go` handlers for metadata, list, delete, and warm-cache endpoints and parameters.",
      "Use `internal/namespace/state.go` to describe metadata fields (schema, index status, unindexed bytes, timestamps).",
      "Add pagination details for list (cursor, prefix, page_size) with response examples."
    ],
    "depends_on": [
      "api-overview"
    ],
    "scope": [
      "docs/api/namespaces.md",
      "pkg/api/router.go",
      "internal/namespace/state.go"
    ],
    "completed": true
  },
  {
    "id": "api-debug-recall",
    "category": "docs",
    "description": "Document debug endpoints including recall and admin-only test/state APIs.",
    "steps": [
      "Use `internal/query/recall.go` and `pkg/api/router.go` to describe request/response schema and defaults for recall.",
      "Document admin token requirements and debug endpoints (`/v1/namespaces/:namespace/_debug/recall`, `/_debug/state/{namespace}`, `/_test/state`).",
      "Add example requests/responses and expected error cases."
    ],
    "depends_on": [
      "api-overview"
    ],
    "scope": [
      "docs/api/debug.md",
      "internal/query/recall.go",
      "pkg/api/router.go"
    ],
    "completed": true
  },
  {
    "id": "architecture-overview",
    "category": "docs",
    "description": "Write an architecture overview covering roles, data flow, storage layout, caching, and routing.",
    "steps": [
      "Summarize system roles and runtime modes from `SPEC.md` and `cmd/vex/main.go`.",
      "Describe the write path (WAL, tail, indexing) using `internal/write/handler.go`, `internal/wal/*`, `internal/indexer/*`, and `internal/tail/store.go`.",
      "Describe query path, cache layers, and routing/membership using `internal/query/handler.go`, `internal/cache/*`, `internal/routing/*`, and `internal/membership/*`.",
      "Add an ASCII diagram and note durability and consistency behaviors."
    ],
    "scope": [
      "docs/architecture.md",
      "SPEC.md",
      "cmd/vex/main.go",
      "internal/write/handler.go",
      "internal/wal/committer.go",
      "internal/indexer/indexer.go",
      "internal/tail/store.go",
      "internal/query/handler.go",
      "internal/cache/disk.go",
      "internal/cache/memory.go",
      "internal/routing/rendezvous.go",
      "internal/membership/membership.go"
    ],
    "completed": true
  },
  {
    "id": "readme-overview",
    "category": "docs",
    "description": "Create the top-level README with project summary, quickstart, and links to detailed docs.",
    "steps": [
      "Use `cmd/vex/main.go` and `cmd/vex/serve/serve.go` to document CLI commands and run modes.",
      "Add quickstart steps (build, run, health check) and link to configuration and API docs in `docs/`.",
      "Summarize features and compatibility goals from `SPEC.md` and link to `docs/architecture.md`."
    ],
    "depends_on": [
      "configuration-reference",
      "api-overview",
      "api-write",
      "api-query",
      "api-namespace-ops",
      "api-debug-recall",
      "architecture-overview"
    ],
    "scope": [
      "README.md",
      "cmd/vex/main.go",
      "cmd/vex/serve/serve.go",
      "SPEC.md",
      "docs/configuration.md",
      "docs/api/overview.md",
      "docs/api/write.md",
      "docs/api/query.md",
      "docs/api/namespaces.md",
      "docs/api/debug.md",
      "docs/architecture.md"
    ],
    "completed": true
  },
  {
    "id": "server-timeouts-from-config",
    "category": "reliability",
    "description": "Honor configured read/write timeouts when creating the HTTP server instead of hard-coded 30s values.",
    "steps": [
      "Update server construction to use config read/write timeouts for both serve and query modes",
      "Add a config-focused test or integration check that asserts timeouts match config defaults",
      "Run the server startup tests and verify no regressions"
    ],
    "completed": false,
    "scope": [
      "cmd/vex/serve/serve.go",
      "cmd/vex/query/query.go",
      "internal/config/config.go"
    ]
  },
  {
    "id": "wal-idempotency-persisted",
    "category": "bug",
    "description": "Persist write idempotency by consulting WAL-sub-batch request_id history so retries across restarts or nodes return original responses.",
    "steps": [
      "Extend idempotency logic to consult WAL history (or a persisted index) for recent request_id entries",
      "Add a test that writes with a request_id, restarts the server, replays the request, and verifies the original response is returned",
      "Run the write/idempotency tests and confirm duplicate requests do not re-apply mutations"
    ],
    "completed": false,
    "scope": [
      "internal/write/idempotency.go",
      "internal/wal"
    ]
  },
  {
    "id": "wal-repair-task-wireup",
    "category": "reliability",
    "description": "Wire the WAL repair task into runtime startup so partial WAL commits are automatically repaired.",
    "steps": [
      "Initialize and schedule the repair task at startup for query/serve modes",
      "Add a test that simulates a WAL upload without state update and verifies repair advances state",
      "Run WAL repair tests and confirm state catches up automatically"
    ],
    "completed": false,
    "scope": [
      "internal/wal/repair.go",
      "cmd/vex/serve/serve.go",
      "cmd/vex/query/query.go"
    ]
  },
  {
    "id": "lsm-query-segment-iterator-implement",
    "category": "bug",
    "description": "Implement LSM QuerySegmentIterator so it iterates indexed segments after tail instead of returning nil.",
    "steps": [
      "Implement iteration across LSM segments in QuerySegmentIterator after tail is consumed",
      "Add a unit test that asserts segments are visited in expected order and not skipped",
      "Run index/query tests and confirm indexed segments are included in results"
    ],
    "completed": false,
    "scope": [
      "internal/index/lsm.go"
    ]
  },
  {
    "id": "ann-debug-logging-remove",
    "category": "observability",
    "description": "Replace fmt.Printf debug prints in ANN query paths with structured logger calls or remove them entirely.",
    "steps": [
      "Remove fmt.Printf statements in the ANN hot path or gate them behind debug logging",
      "Add a test (or log assertion) to ensure no raw stdout prints occur during queries",
      "Run query tests and confirm logs remain structured"
    ],
    "completed": false,
    "scope": [
      "internal/query/handler.go"
    ]
  },
  {
    "id": "ram-eviction-priority-enforce",
    "category": "bug",
    "description": "Respect cache item priority tiers when enforcing per-namespace RAM caps so tail data is evicted last.",
    "steps": [
      "Update per-namespace eviction to sort by priority before LRU when trimming to caps",
      "Add a test that loads mixed-priority items and verifies tail data is retained longest",
      "Run cache tests and confirm eviction order honors priority tiers"
    ],
    "completed": false,
    "scope": [
      "internal/cache/memory.go"
    ]
  },
  {
    "id": "gossip-self-api-addr-config",
    "category": "reliability",
    "description": "Derive the gossip self API address from the actual listen address to avoid misrouting when ports differ.",
    "steps": [
      "Use the configured listen address when setting the self API address in gossip membership",
      "Add a test with non-8080 listen ports to ensure self address matches actual server",
      "Run membership/routing tests and confirm proxying selects the correct home node"
    ],
    "completed": false,
    "scope": [
      "internal/membership/gossip.go",
      "internal/config/config.go"
    ]
  },
  {
    "id": "disk-cache-missing-file-heal",
    "category": "bug",
    "description": "Handle missing disk cache files by treating them as cache misses and cleaning up metadata.",
    "steps": [
      "On cache Get, verify file existence and delete cache metadata if missing",
      "Add a test that deletes cached files and verifies Get reports a miss and cleans metadata",
      "Run cache tests and confirm no repeated hit accounting on missing files"
    ],
    "completed": false,
    "scope": [
      "internal/cache/disk.go"
    ]
  },
  {
    "id": "delete-namespace-gc-trigger",
    "category": "bug",
    "description": "Trigger background GC after namespace deletion to remove namespace objects and catalog entries.",
    "steps": [
      "Wire delete handler to enqueue/trigger namespace GC after tombstone/state update",
      "Add a test that deletes a namespace and verifies GC is invoked and keys are removed",
      "Run delete/GC tests and confirm tombstoned namespaces are cleaned up"
    ],
    "completed": false,
    "scope": [
      "pkg/api/router.go",
      "internal/gc"
    ]
  },
  {
    "id": "validate-state-format-version",
    "category": "bug",
    "description": "Validate state.json format_version on load and reject unsupported versions with a clear error.",
    "steps": [
      "Add format_version checks in state loading logic with supported version bounds",
      "Add a test that loads an unsupported version and expects a deterministic error",
      "Run namespace/state tests and verify valid versions still load"
    ],
    "completed": false,
    "scope": [
      "internal/namespace/manager.go"
    ]
  },
  {
    "id": "validate-index-manifest-version",
    "category": "bug",
    "description": "Validate index manifest format_version on load and error on unsupported versions.",
    "steps": [
      "Add format_version checks in manifest reader with supported version bounds",
      "Add a test that loads an unsupported manifest version and expects an error",
      "Run index reader tests and confirm supported manifests still load"
    ],
    "completed": false,
    "scope": [
      "internal/index/reader.go"
    ]
  },
  {
    "id": "integration-gzip-size-limit",
    "category": "test",
    "description": "Add integration coverage for gzip request bodies that inflate past the 256MB limit to confirm 413 responses.",
    "steps": [
      "Add an integration test that sends a gzip-compressed body which inflates past 256MB",
      "Run `go test ./tests/integration -run GzipSizeLimit` and confirm it fails before fixes",
      "Fix size enforcement and re-run the test to confirm 413 is returned"
    ],
    "completed": false,
    "scope": [
      "tests/integration"
    ]
  },
  {
    "id": "integration-idempotency-restart",
    "category": "test",
    "description": "Add an integration test to verify request_id deduplication works across server restarts or different nodes.",
    "steps": [
      "Add an integration test that submits a write, restarts the server (or routes to another node), and replays the same request_id",
      "Run `go test ./tests/integration -run IdempotencyRestart` and confirm it fails before fixes",
      "Implement persisted idempotency and re-run the test to confirm original response reuse"
    ],
    "completed": false,
    "scope": [
      "tests/integration",
      "internal/write",
      "internal/wal"
    ]
  }
]
